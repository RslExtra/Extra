/**
   @Package RUnit

   InMemory Database. Позволяет динамически создавать, заполнять структуру со схожим интерфейсом [TbFile].
   Предназначен для тестирования работы макросов с предопределенным значением полей.

   Пример использования:

   @sample [samples.RUnit.MemDb]
*/

import rcw;
import "..\\mac\\Extra\\Collections\\ArrayList.mac";
import "..\\mac\\Extra\\Utils\\StringUtils.mac";
import "..\\mac\\Extra\\Utils\\SArray.mac";

private var tmpArr = TArray;
private const dbfilePath = "..\\dbfile\\";

/**
   Расширение стандартного класса [TRecHandler] для работы с [MemDB].
*/
Private Class (TRecHandler) MockTRecHandler(strName, altDic, _file, _index, _offs, isFixed)
   initTRecHandler(strName, altDic, _file, _index, _offs, isFixed);
   var __pos = -1;
End;

Private Macro naturalOrderCompare(rh1, rh2)
   return (rh1.__pos - rh2.__pos);
end;

Private Class RecComparator()
   private var propsId  = TArray();
   private var order    = TArray();

   tmpArr[tmpArr.size] = this;

   Macro addProp(ind : Integer, asc : Bool)
      propsId[propsId.size] = ind;
      if (asc)
         order[order.size] = 1;
      else
         order[order.size] = -1;
      end;
   End;

   Macro compare(o1, o2) : Integer
      for (var i, 0, propsId.size-1, 1)
         var id  = propsId[i];
         var p1 = o1.rec[id];
         var p2 = o2.rec[id];
         var resCompare = 0;
         if (p1 > p2)
            resCompare = order[i];
         elif (p1 < p2)
            resCompare = -order[i];
         end;
         if (resCompare != 0)
            return resCompare;
         end;
      end;
      return 0;
   End;

   Macro compareWithPos(o1, o2)
      var c = compare(o1, o2);
      if (c != 0) return c; end;
      return naturalOrderCompare(o1, o2);
   End;

   Macro getFunc()
      return (R2M(this, "compare"));
   End;

   Macro getAddingFunc()
      return (R2M(this, "compareWithPos"));
   End;
End;

Private Class DBKey(_num)
   var comparatorBuilder = RecComparator();
   var comparator = null;
   var addComparator = null;
   var num = _num;
   var keyInfo = SArray();

   Macro addProp(id, asc)
      var ord = 1;
      if (not(asc)) ord = 0; end;
      keyInfo.addItems(num, Int(keyInfo.size/5), id, ord, 0);
      comparatorBuilder.addProp(id, asc);
   End;

   Macro build()
      comparator = comparatorBuilder.getFunc();
      addComparator = comparatorBuilder.getAddingFunc();
      return this;
   End;
End;

/**
   Билдер структуры во время исполнения программы.
*/
Class StructureBuilder(_name : String)
   var name = _name;
   var fieldsDef = SArray();

   Macro setName(_name : String)
      name = _name;
      return this;
   End;

   /**
      Добавляет поле таблицы бд с именем '_name', типом '_type', размером '_size' и количеством знаков после запятой для дробных типов '_float'.
   */
   Macro addField(_name : String, _type : Integer, _size : Integer, _float : Integer)
      if (ValType(_name) != V_STRING)
         RunError("Параметр name должен быть строкой");
      end;
      if (ValType(_type) != V_INTEGER)
         RunError("Параметр name должен быть числовой константой типа.");
      end;
      fieldsDef.addItems(_name, _type, _size, _float, 0);
      return this;
   End;

   /**
      Возвращает структуру типа [MockTRecHandler] из предварительно заданных полей.
   */
   Macro build() : MockTRecHandler
      var handler = MockTRecHandler(name, fieldsDef);
      var a = handler.getFldInfo;
      return handler;
   End;
End;

Private Macro binarySearchMap(arr : TArray, el : Variant,  comp) : Integer
   var high = arr.size, low = 0, mid = 0, x;
   var i = -1;
   while(low < high)
      mid = (low + high) / 2;
      x = arr[mid];
      if (ExecMacro2(comp, el, x) == 0)
         return mid;
      elif (ExecMacro2(comp, el, x) < 0)
         high = mid;
         i = -mid-1;
      else
         low = mid + 1;
         i = -low-1;
      end;
   end;
   return i;
End;

Private Macro binarySearchFirst(arr : TArray, el : Variant,  comp) : Integer
   var s = binarySearchMap(arr, el, comp);
   if (s <= 0)
      return s;
   end;
   while (s > 0)
      if (ExecMacro2(comp, arr[s], arr[s-1]) != 0)
         break;
      end;
      s = s - 1;
   end;
   return s;
End;

Private Macro binarySearchLast(arr : TArray, el : Variant,  comp) : Integer
   var s = binarySearchMap(arr, el, comp);
   if (s == (arr.size) or (s < 0))
      return s;
   end;
   while (s < arr.size-1)
      if (ExecMacro2(comp, arr[s], arr[s+1]) != 0)
         return s;
      end;
      s = s + 1;
   end;
   return arr.size;
End;

/**
   Класс таблицы в памяти. Единственным и обязательным параметром является структура '_struct' типа [MockTRecHandler]. Которая определяет структуру полей бд, которую необходимо предварительно собрать с помощью [StructureBuilder].

   'Offtop:' - вообще предусматривалась возможность передать реальный [TBFile] в '_struct', чтобы скопировать все ключи и поля реальной таблицы, однако эта возможность не тестировалась. Можете попробовать и пофиксить последующие баги, тогда генерация таблицы будет еще проще, однако станет не удобным добавлять все поля бд, даже те, которые не нужны в конкретном тесте.
*/
Class MemDB(_struct)
   var rec = _struct.rec;
   var keyNum = -1;
   var TblName = _struct.TblName;
   var DicName = "";
   var OpenMode = "R";

   private var natural = SArray();
   private var lastKeyNum    = -1;
   private var curDataSet    = natural;
   private var curComparator = @naturalOrderCompare;
   private var struct = _struct;
   var buff = null;
   private var cursor = -1;
   private var dataSets = SArray();
   private var keys = SArray();
   private var curIndex = 1;
   private var lastGetPos = -1;

   Private Macro addInDataSet(k, rh)
      var d = dataSets[k];
      var comp = keys[k].addComparator;
      var pl = binarySearchLast(d, rh, comp);
      if (pl >= 0)
         d.add(rh, pl);
      else
         d.add(rh, -(pl+1));
      end;
   End;

   Private Macro addInAllDataSet(rh)
      natural.push(rh);
      for(var i, 0, dataSets.size-1, 1)
         if (dataSets[i] != null)
            addInDataSet(i, rh);
         end;
      end;
   End;

   Private Macro removeInDataSet(k, rh)
      var d = dataSets[k];
      for (var i, 0, d.size-1, 1)
         if (d[i].__pos == rh.__pos)
            d.remove(i);
            break;
         end;
      end;
   End;

   Private Macro RemoveInAllDataSet(rh)
      var ns = binarySearchMap(natural, rh, @naturalOrderCompare);
      if (ns >= 0)
         natural.remove(ns);
      end;
      for(var i, 0, dataSets.size-1, 1)
         if (dataSets[i] != null)
            removeInDataSet(i, rh);
         end;
      end;
   End;

   Private Macro newRec() : MockTRecHandler
      var r = MockTRecHandler(buff.TblName, buff.getFldInfo);
      r.__pos = curIndex;
      curIndex = curIndex + 1;
      return r;
   End;

   /**
      Добавляет строку в бд, значения полей перечисляются в аргументах метода.
   */
   Macro addRow()
      var newRow = newRec();
      var i = 0, v;
      while(getParm(i+1, v))
         newRow.rec[i] = v;
         i = i + 1;
      end;
      addInAllDataSet(newRow);
      return this;
   End;

   Private macro dataSetCopy(k)
      var datas = dataSets[k];
      datas.addArray(natural);
      datas.sort(keys[k].addComparator);
   End;

   /**
      Добавляет ключ бд под номером 'num'. Далее в  аргументах перечисляются имена полей. Обратный порядок сортировки задается знаком '-' перед полем.
   */
   Macro addKey(num : Integer)
      var kb = DBKey(num);
      var i = 0, asc = true, v;
      while (GetParm(i+2, v))
         if (SubStr(v, 1, 1) == "-")
            asc = false;
            v = SubStr(v, 2);
         end;
         kb.addProp(GenPropId(rec, v), asc);
         i = i + 1;
      end;
      kb.build();
      keys[num] = kb;
      dataSets[num] = SArray;
      dataSetCopy(num);
      return this;
   End;

   Private Macro copyBuff()
      Copy(buff, curDataSet[cursor]);
      buff.__pos = curDataSet[cursor].__pos;
   End;


   Private Macro restoreCursor()
      if (cursor == -1) return; end;
      var s = binarySearchMap(curDataSet, buff, @naturalOrderCompare);
      cursor = s;
   End;

   Private Macro checkKeyNum()
      if (lastKeyNum != keyNum)
         if (keyNum == -1)
            curDataSet = natural;
            curComparator = @naturalOrderCompare;
            restoreCursor();
         else
            if ((keys.size-1 < keyNum) or (keys[keyNum] == null))
               RunError("Ключ БД не определен " + keyNum);
            end;
            curDataSet = dataSets[keyNum];
            curComparator = keys[keyNum].comparator;
            restoreCursor();
         end;
      end;
      lastKeyNum = keyNum;
   End;

   /**
      Возвращает количество записей бд.
   */
   Macro NRecords() : Integer
      return natural.size;
   End;

   /**
      Очищает буфер.
   */
   Macro clear()
      for (var i, 0, GenNumProps(buff.rec)-1, 1)
         buff.clear;
      end;
   End;

   /**
      Переводит курсор в начало таблицы.
   */
   Macro rewind()
      cursor = -1;
      checkKeyNum();
   End;

   /**
      Возвращает физическую позицию текущей записи в буфере.
   */
   Macro getPos() : Integer
      lastGetPos = buff.__pos;
      return lastGetPos;
   End;

   /**
      Переводит курсор бд в позицию на которой был последний вызов [GetPos].
   */
   Macro getDirect(pos) : Bool
      if (ValType(pos) == V_UNDEF)
         pos = lastGetPos;
      end;
      buff.rec.__pos = pos;
      var sn = binarySearchMap(natural, buff, @naturalOrderCompare);
      if (sn < 0) return false; end;
      var s = binarySearchMap(curDataSet, natural[sn], @curComparator);
      if (s < 0) return false; end;
      cursor = s;
      copyBuff();
   End;

   Macro item(ni)

   End;

   /**
      Переводит курсор на следующую запись и возвращает `true` если она существует.
   */
   Macro next() : Bool
      checkKeyNum();
      if (cursor >= (natural.size-1))
         return false;
      end;
      cursor = cursor + 1;
      copyBuff();
      return true;
   End;

   /**
      Переводит курсор на предыдущую запись и возвращает `true` если она существует.
   */
   Macro prev() : Bool
      checkKeyNum();
      if ((cursor == 0) or (natural.size == 0))
         return false;
      end;
      if (cursor == -1)
         cursor = natural.size;
      end;
      cursor = cursor - 1;
      copyBuff();
      return true;
   End;

   /**
      Выполняет операцию добавления новой строки из буфера.
   */
   Macro insert()
      var newRow = newRec();
      for (var i, 0, GenNumProps(buff.rec)-1, 1)
         newRow[i] = buff[i];
      end;
      addInAllDataSet(newRow);
   End;

   /**
      Выполняет операцию обновления текущей строки из буфера.
   */
   Macro update() : Bool
      if (cursor >= 0)
         copy(curDataSet[cursor], buff);
      end;
      return false;
   End;

   /**
      Выполняет операцию удаления строки из бд с физической позицией строки из буфера.
   */
   Macro delete() : Bool
      if (cursor >= 0)
         RemoveInAllDataSet(curDataSet[cursor]);
         cursor = cursor - 1;
         return true;
      end;
      return false;
   End;

   /**
      Метод аналогичен [TBFile.GetEQ].
   */
   Macro getEQ() : Bool
      checkKeyNum();
      var r = binarySearchFirst(curDataSet, buff, curComparator);
      if (r < 0)
         return false;
      end;
      cursor = r;
      copyBuff();
      return true;
   End;

   /**
      Метод аналогичен [TBFile.getGE].
   */
   Macro getGE() : Bool
      checkKeyNum();
      var r = binarySearchFirst(curDataSet, buff, curComparator);
      if (r < 0)
         r = (-r-1);
      end;
      if (r == natural.size)
         return false;
      end;

      cursor = r;
      copyBuff();
      return true;
   End;

   /**
      Метод аналогичен [TBFile.getGT].
   */
   Macro getGT() : Bool
      checkKeyNum();
      var r = binarySearchFirst(curDataSet, buff, curComparator);
      if (r < 0)
         r = (-r-1);
      else
         r = r + 1;
      end;
      if (r == natural.size)
         return false;
      end;

      cursor = r;
      copyBuff();
      return true;
   End;

   /**
      Метод аналогичен [TBFile.getLE].
   */
   Macro getLE() : Bool
      checkKeyNum();
      var r = binarySearchLast(curDataSet, buff, curComparator);
      if (r == -1)
         return false;
      end;
      if (r < 0)
         r = -r - 2;
      end;
      cursor = r;
      copyBuff();
      return true;
   End;

   /**
      Метод аналогичен [TBFile.getLT].
   */
   Macro getLT() : Bool
      checkKeyNum();
      var r = binarySearchLast(curDataSet, buff, curComparator);
      if ((r == -1) or (r == 0))
         return false;
      elif (r < 0)
         r = -r - 2;
      else
         r = r - 1;
      end;
      cursor = r;
      copyBuff();
      return true;
   End;

   /**
      Возращает массив структуры полей.
   */
   Macro getFldInfo()
      return struct.getFldInfo();
   End;

   /**
      Возращает массив структуры ключей.
   */
   Macro getKeyInfo()
      if (IsEqClass("TBFile", struct))
         return struct.getKeyInfo();
      end;
      var res = SArray();
      for (var k, keys)
         if (k != null)
            res.addArray(k.KeyInfo);
         end;
      end;
      return res;
   End;

   Private Macro createKeysFromTB(kinf)
      var n, s, f, o, k;
      var curK = -1;
      for (var i, 0, kinf.size - 1, 5)
         n = kinf[i];
         s = kinf[i+1];
         f = kinf[i+2];
         o = kinf[i+3];
         if (n != curK)
            if (k != null)
               k.build();
               keys[curK] = k;
               dataSets[curK] = SArray();
               dataSetCopy(curK);
            end;
            k = DbKey(n);
            curK = n;
         else
            k.addProp(f, (o == 1));
         end;
      end;
   End;

   Macro ini()
      if (IsEqClass("TRecHandler", struct))
         buff = struct;
      elif (IsEqClass("TBFile", struct))
         buff = MockTRecHandler(struct.TblName, struct.getFldInfo);
         createKeysFromTB(struct.getKeyInfo);
      end;
   end;

   ini();
End;
