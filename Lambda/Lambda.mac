/**
   @package Lambda
   @title   Лямбда-функции
   @ancestor Extra

   Библиотека для динамического создания функций из строковых шаблонов.
   Принцип работы основан на кодогенерации. Выражение преобразуется в код макрофункции, затем он записывается в файл, динамически импортируется в текущий контекст, временный файл удаляется, метод остается доступен по ссылке в переменной, который можно вызвать через стандартные [ExecMacro2] или [CallR2M].
   Используется в библиотеках:
    - [Collections]
    - [StreamApi]
    - [Utils.SArray]
*/

import rsexts;
import "..\\Mac\\Extra\\OOP\\Exceptions.mac";

/**
   Singleton instance [LambdaClass].
*/
const Lambdas = GenObject("LambdaClass");

/*
   Вспомогательная функция для нахождения последнего вхождения подстроки в строке.
*/
Private Macro IndexRev(srcStr : String, findStr : String, startPos:  Integer) : Integer
   if ((ValType(startPos) != V_INTEGER))
      startPos = StrLen(srcStr);
   end;
   var findLen = StrLen(findStr);
   if (findLen == 0) return 0; end;
   for(var i, startPos - findLen + 1, 1, -1)
      if (SubStr(srcStr, i, findLen) == findStr)
         return i;
      end;
   end;
   return 0;
End;

/*
   Получаем папку для записи временных файлов
*/
Private Macro getWorkDirPath() : String
   var path = ExecMacro2("getRegVal", "BANK_INI\\ОБЩИЕ ПАРАМЕТРЫ\\ДИРЕКТОРИИ\\WORKDIR", true);
   if((ValType(path) != V_UNDEF) and (path != ""))
      return path;
   end;
   return "..\\WorkFile\\";
End;

/*
   Вспомогательная функция для проверки корректности текста лямбда выражения.
*/
Private macro checkLambdaText(lambdaText) : Bool
   return true;
   if ((Index(lambdaText, Lambdas.ARROW) < 1) and (Index(lambdaText, Lambdas.DEFARG) < 1))
      return false;
   end;
   return true;
End;

Private Class LambdaGen()
   var filename;
   var clname;
   var dirPath = ExecMacro2("getWorkDirPath");
   var tmpFile : TStreamDoc;
   var un = UserNumber();

   /* Массив уже сгенерированных функций */
   private var LamArray = TArray();             // Массив уже сгенерированных лямбд

   /* Количество сгенерированных функций, для избежания коллизий.*/
   private var countLambdas = 0;

   Macro add(l)
      LamArray[LamArray.size] = l;
   end;

   Macro getCount()
      return countLambdas;
   End;

   Macro incCount()
      countLambdas = countLambdas + 1;
      return countLambdas;
   End;

   Macro generateFileName()
      filename = dirPath + Lambdas.FILE_PREFIX + un + "_" + countLambdas + "." + (1000 + Random(8999));
   End;

   Macro createFile() : Bool
      TmpFile = TStreamDoc (filename, "W","rsoem");
      return true;
      onError
         Throw(IOException("Ошибка при создании файла лямбда-функции " + filename));
         return false;
   End;

   Macro writeTempFile(funcText)
      funcText = Trim(funcText);
      var indArrow = Index(funcText, Lambdas.ARROW);
      var args = SubStr(funcText, 1, indArrow - 1);
      var body = SubStr(funcText, indArrow + 2);
      if (indArrow == 0)
         args = Lambdas.DEFARG;
         body = funcText;
      end;
      if (Substr(body, StrLen(body)) == ";")         // отрезаем крайнюю ';'
         body = Substr(body, 1, StrLen(body) - 1);
      end;
      var lastSepInd = IndexRev(body, ";");         // ищем последнюю ';'
      var firstPart = SubStr(body, 1, lastSepInd);  // Выделяем части до и после, чтобы добавить к последней return;
      var lastPart  = SubStr(body, lastSepInd + 1);
      var textMacro = "Macro lam" + "(" +  args + ") " + firstPart +"return (" + lastPart + "); end; ";
      var lambdaText = StrSubst(funcText, "\"", "\\\"");
      textMacro = StrSubst(textMacro, "'", "\"");         // Меняем апострофы на кавычки
      TmpFile.writeLine("class " + clname +"()");
      TmpFile.writeLine("var ___filename = \"" + StrSubst(filename, "\\", "\\\\") +"\";");
      TmpFile.writeLine("var ___lambdaText = \"" + lambdaText + "\";");
      TmpFile.writeLine(textMacro);
      TmpFile.writeLine("End;");
      TmpFile = null;
   end;

   Macro makeMacro(l)
      clname = "LamObject" + incCount();
      generateFileName();
      createFile();
      writeTempFile(l);
      instLoadModule(filename);
      var lob = GenObject(clname);
      add(lob);
      return R2M(lob, "lam");
   End;

   Macro findExistLambda(candidate)
      for(var lamObj, LamArray)
         if (lamObj.___lambdaText == candidate)
            return R2M(lamObj, "lam");
         end;
      end;
   End;

   Macro removeAllFiles()
      for (var l, LamArray)
         removeFile(l.___filename);
      end;
   End;
End;

/**
   Основной класс библиотеки, содержит в себе настройки и методы для создания функций из текстовых выражений; представлен singleton [Lambdas].
*/
Private Class LambdaClass()

   /**
      Флаг автоматического удаления сгенерированных файлов. Если установить его в значение `false`, все сгенерированные файлы будут доступны в рабочем каталоге. По умолчанию равен `true`.
   */
   var REMOVE_FILES : Bool = true;

   /** Строковое значение стрелки в лямбда выражении; по умолчанию равно '->'. */
   var ARROW : String = "->";

   /** Имя аргумента функции для использования без "стрелки"; по умолчанию равно 'it'. */
   var DEFARG : String = "it";

   /** Префикс имени файлов; по умолчанию 'lam_' */
   var FILE_PREFIX = "lam_";

   /* Генератор лямб */
   Private var lGen = GenObject("LambdaGen");   // Генератор лямбд

   /**
      Сбрасывает настройки по умолчанию.
   */
   Macro reset()
      REMOVE_FILES = true;
      ARROW = "->";
      DEFARG = "it";
      FILE_PREFIX = "lam_";
      return this;
   End;



   /**
      Возвращает ссылку на сгенерированный метод согласно выражению 'lambdaText'.
      Функция генерируется по следующим алгоритмам. Слева от стрелки через запятую перечисляются параметры функции с любыми именами, затем идет стрелка (по умолчанию '->'), справа от стрелки идет тело функции. Последнее выражение после ';' (если имеется) передается в 'return'. Для удобства чтения, внутри текста лямбды вместо символа двойных кавычех рекомендуется использовать символ одинарных.

      Например:
   ```
      var ref = Lambda("i, j -> println(i + ' and ' + j); i+j");
      /*
         В результате будет сгененирована функция вида
         Macro lam(i, j)
            println(i + " and " + j);
            return (i+j);
         End;
      */

      // Вызываем функцию
      var result = ExecMacro2(ref, 10, 23);  // 10 and 23
      println(result);   // 33
   ```
      Если фукция с одним аргументом, есть возможность упростить запись лямбда-выражения, передав только тело функции, где именем входного параметра будет являться 'it'. Например:
   ```
      var sqRef = Lambda("it*it");      // Функция возведения в квадрат
      var b = ExecMacro2(sqRef, 5);
      println(b);                     // 25
   ```

   */
   Macro create(lambdaText : String)
      if (checkLambdaText(lambdaText))
         return lGen.makeMacro(lambdaText);
      else
         return Throw(IllegalArgumentException("Неверное лямбда-выражение \n" + lambdaText));
      end;
   End;

   Macro isLambda(candidate : String) : Bool
      if (SubStr(candidate, 1, 1) == "@")
         return false;
      end;
      return true;
   End;

   Private Macro getFunctionRef(funcName)
      var r = ExecExp(funcName);
      if (ValType(r) != V_PROC)
         Throw(IllegalArgumentException("Имя не соответсвует функции: " + funcName));
      end;
      return r;
      OnError
         Throw(IllegalStateException("Не найден функция с именем " + funcName));
   End;

   /**
      Возвращает ссылку на функцию или бросает исключение. Функция принимает 'candidate' которая должна быть или ссылкой на функцию, или корректным лямбда-выражением типа String. Также допускается передать имя функции, однако перед именем должен быть символ `@`, например `getFunc("@println")`. Может использоваться как адаптер в библиотеках, где необходима возможность использовать лямбда-функции.
   */
   Macro getFunc(candidate : Variant)
      var type = ValType(candidate);
      if ((type == V_PROC) or (type == V_R2M))
         return candidate;
      elif (type == V_STRING)
         //return lGen.findOrGenerate(candidate);
         if (isLambda(candidate))
            var finded = lGen.findExistLambda(candidate);
            if (ValType(finded) != V_UNDEF)
               return finded;
            end;
            return create(candidate);
         else
            return getFunctionRef(candidate);
         end;
      else
         return Throw(IllegalArgumentException("Неверный тип для создания лямбда-выражения"));
      end;
   End;

   Macro Destructor()
      if (REMOVE_FILES)
         lgen.removeAllFiles();
      end;
   End;
End;

/**
   Делает тоже самое что и [LambdaClass.getFunc Lambdas.getFunc()].
*/
Macro GetLambdaFunc(candidate)
   return Lambdas.getFunc(candidate);
End;

/**
   Функция-маркер для проверки загрузки библиотеки.
*/
Macro LambdaLoadedMarker()
   return 1;
End;