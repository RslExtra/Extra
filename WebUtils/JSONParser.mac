import rcw;
import "..\\mac\\extra\\WebUtils\\Fields.mac";
import "..\\mac\\extra\\Utils\\TimeUtils.mac";
import "..\\mac\\extra\\Utils\\Sarray.mac";
import "..\\mac\\extra\\Utils\\StringUtils.mac";
import "..\\mac\\extra\\Collections\\ArrayMap.mac";
import "..\\mac\\extra\\OOP\\Exceptions.mac";

private var SU = StringUtils;
private var parsedClassMap = ArrayMap();

Private Macro getObjectCustomMap(className : String)
   var lwr = StrLwr(className);
   var customMap = parsedClassMap.get(lwr);
   if (ValType(customMap) == V_UNDEF)
      customMap = ArrayMap();
      var obj = GenObject(className);
      for (var i, 0, GenNumProps(obj) - 1, 1)
         if (IsEqClass("CustomField", obj[i]))
            var cp = obj[i];
            customMap.put(cp.fieldName, i);
         end;
      end;
      parsedClassMap.put(lwr, customMap);
   end;
   return customMap;
End;

Private Macro UnusedFieldsToNull(obj)
   var pc = GenNumProps(obj);
   var i;
   for (i, 0, pc - 1, 1)
      if ((ValType(obj[i]) != V_UNDEF) and (IsEqClass("FieldClass", obj[i])))
         obj[i] = null;
      end;
   end;
End;

private Macro isSystemName(_name) : Bool
   var mn = ModuleName(_name);
   return (mn != "");
End;

Private Macro getStrOpenClose(str, from, op, cl)
   var res = "";
   var c = 0;
   for (var i, from, StrLen(str))
      var s = SubStr(str, i, 1);
      if (s == op)
         c = c + 1;
      end;
      if (s == cl)
         c = c - 1;
      end;
      res = res + s;
      if (c == 0)
         break;
      end;
   end;
   // res = SubStr(res, 2, StrLen(res) - 1);
   return res;
End;

Private Macro CreateObjectByName(clName : String)
   var obj = GenObject(clName);
   return obj;
   OnError
      return null;
End;

Private Macro getPrimItems(str) : SArray
   var result = SArray;
   var isOpen = false;
   var part = "";
   var s;

   for (var i, 1, StrLen(str), 1)
      s = SubStr(str, i, 1);
      if (s == "\"")
         isOpen = not(isOpen);
         s = "";
      end;
      if ((open == false) and (s == ","))
         result.push(part);
         part = "";
      elif (s == " ")
      else
         part = part + s;
      end;
   end;
   if (part != "")
      result.push(part);
   end;
   return result;
End;

Private Macro getProps(str) : SArray
   var result = SArray();
   var isOpen = false;
   var i = 1;
   var s, block, part = "";
   while (i <= StrLen(str))
      s = SubStr(str, i, 1);
      if (s == "\"")
         isOpen = not(isOpen);
      end;
      if ((isOpen == false))
         if (s == ",")
            result.push(part);
            part = "";
            i = i + 1;
         elif (s == "{")
            block = getStrOpenClose(str, i, "{", "}");
            part = part + block;
            i = i + StrLen(block);
         elif (s == "[")
            block = getStrOpenClose(str, i, "[", "]");
            part = part + block;
            i = i + StrLen(block);
         else
            part = part + s;
            i = i + 1;
         end;
      else
         part = part + s;
         i = i + 1
      end;
   end;
   if (part != "")
      result.push(part);
   end;
   return result;
End;

Private Macro GetNextProp(str, ind, prop : String) : Bool
   var result = "";
   var block;
   var isOpen = false;
   while (ind <= StrLen(str))
      var s = SubStr(str, ind, 1);
      if (s == "\"")
         isOpen = not(isOpen);
      end;
      if ((isOpen == false))
         if (s == ",")
            ind = ind+1;
            SetParm(1, ind);
            SetParm(2, result);
            return true;
         elif (s == "{")
            block = "{" + getStrOpenClose(str, ind, "{", "}") + "}";
            result  = result + block;
            ind = ind + StrLen(block);
         elif (s == "[")
            block = "[" + getStrOpenClose(str, ind, "[", "]") + "]";
            result = result + block;
            ind = ind + StrLen(block);
         else
            result = result + s;
            ind = ind + 1;
         end;
      else
         result = result + s;
         ind = ind + 1
      end;
   end;
   if (result != "")
      SetParm(1, ind);
      SetParm(2, result);
      return true;
   end;
   return false;
End;

Private macro choosePrimType(type) : FieldClass
   if (type == V_INTEGER)
      return IntegerField;
   elif (type == V_STRING)
      return StringField;
   elif (type == V_BOOL)
      return BoolField;
   elif (type == V_MONEY)
      return MoneyField;
   elif (type == V_DOUBLE)
      return DoubleField;
   end;
End;

Private Macro ParseFromJSON(jsonString : String, pojoClassNameOrField : Variant)
   var obj;
   if (SubStr(jsonString, 1, 1) == "{")
      jsonString = SubStr(jsonString, 2, StrLen(jsonString) - 2);
      obj = ExecMacro2("parseObject", jsonString, pojoClassNameOrField);
   elif (SubStr(jsonString, 1, 1) == "[")
      if (ValType(pojoClassNameOrField) == V_STRING)
         pojoClassNameOrField = ObjectField(pojoClassNameOrField);
      elif (ValType(pojoClassNameOrField) == V_UNDEF)
         pojoClassNameOrField = VariantField;
      end;
      obj = ExecMacro2("parseArray", jsonString, pojoClassNameOrField);
   else
      Throw(IllegalArgumentException("JSON is not valid"));
   end;
   return obj;
End;

Private Macro parseArray(str, type : FieldClass)
   var result = SArray();
   var tmpstr = str;
   if (SubStr(tmpstr, 1, 1) == "[")
      tmpstr = SubStr(tmpstr, 2, StrLen(tmpstr) - 2);
   end;
   if ((SubStr(tmpstr, 1, 1) == "{") and (ValType(type) != V_UNDEF))
      while (true)
         var strObj = getStrOpenClose(tmpstr, 1,"{", "}");
         var newObj = type.parseValue(strObj, @ParseFromJSON);
         if (ValType(newObj) != V_UNDEF)
            result.push(newObj);
         end;
         tmpstr = SubStr(tmpstr, StrLen(strObj) + 2);
         if (tmpstr == "") break; end;
      end;
   else
      var items = getPrimItems(tmpstr);
      for (var it, items)
         result.push(type.parseValue(it));
      end;
   end;
   return result;
End;

Private Macro parseProp (field, strVal)
   if (SubStr(strVal, 1, 1) == "\"")
      strVal = SubStr(strVal, 2, StrLen(strVal) - 2);
   end;
   if (isEqClass("FieldClass", field))
      return field.parseValue(strVal, @ParseFromJSON);
   end;
   return strVal;
End;
/*
Private Macro parseObject(str, className) : Object
   var resultObject = GenObject(className);

   if (SubStr(str, 1, 1) == "{")
      str = SubStr(str, 2, StrLen(str) - 2);
   end;
   var customMap = getObjectCustomMap(className);
   var hascustom = (customMap.size > 0);
   var pr, ind = 1;
   while (GetNextProp(str, ind, pr))
      var pos = Index(pr, ":");
      if (pos > 0)
         var propName = SubStr(pr, 2, pos-3);
         var value = SubStr(pr, pos + 1);
         if (ModuleName(propname) == "SYSTEM")
            propname = "_" + propname;
         end;
         var id = genPropID(resultObject, propname);
         if (id >= 0)
            var field = resultObject[id];
            resultObject[id] = parseProp(field, value);
         else
            if (hascustom)
               id = customMap.get(StrLwr(propname));
               if (ValType(id) == V_INTEGER)
                  resultObject[id] = parseProp(resultObject[id], value);
               end;
            end;
         end;
      end;
   end;
   UnusedFieldsToNull(resultObject);
   return resultObject;

   OnError
      return null;
End;
*/

Private Macro parseObject(str, className) : Object
   var resultObject = GenObject(className);

   if (SubStr(str, 1, 1) == "{")
      str = SubStr(str, 2, StrLen(str) - 2);
   end;
   var customMap = getObjectCustomMap(className);
   var hascustom = (customMap.size > 0);
   var props = getProps(str);
   for (var pr, props)
      var pos = Index(pr, ":");
      if (pos > 0)
         var propName = SubStr(pr, 2, pos-3);
         var value = SubStr(pr, pos + 1);
         if (ModuleName(propname) == "SYSTEM")
            propname = "_" + propname;
         end;
         var id = genPropID(resultObject, propname);
         if (id >= 0)
            var field = resultObject[id];
            resultObject[id] = parseProp(field, value);
         else
            if (hascustom)
               id = customMap.get(StrLwr(propname));
               if (ValType(id) == V_INTEGER)
                  resultObject[id] = parseProp(resultObject[id], value);
               end;
            end;
         end;
      end;
   end;
   UnusedFieldsToNull(resultObject);
   return resultObject;

   OnError
      return null;
End;

// TO JSON


Private Macro formatJsonKey(propName)
   propName = StrLwr(propname);
   if (SubStr(propname, 1, 1) == "_")
      propname = SubStr(propname, 2);
   end;
   return "\"" + propName + "\":";
end;

Private Macro formatJsonValue(val : Variant, type)
   var vt = ValType(val);
   if ((IsEqClass("ArrayField", type)) or (IsEqClass("ObjectField", type)))
      return val;
   elif (vt == V_STRING)
      return "\"" + val + "\"";
   elif ((vt == V_BOOL) or (vt == V_INTEGER) or (vt == V_MONEY) or (vt == V_DOUBLE))
      return val;
   else
      return "\"" + val + "\"";
   end;
End;

Private Macro SomeToJSONString(val : Variant, type) : String
   if (ValType(val) == V_UNDEF)
      return "";
   elif (ValType(val) == V_GENOBJ)
      if (IsEqClass("TARRAY", val))
         return ExecMacro2("arrayToJSONString", val, type);
      else
         return ExecMacro2("objectToJSONString", val, null);
      end;
   elif (IsEqClass("FieldClass", type))
      return type.formatJSON(val, @SomeToJSONString);
   else
      return formatJsonValue(val);
   end;
   return "";
End;

Private Macro objectToJSONString(obj, type) : String
   var result = "{";
   var model  = GenObject(GenClassName(obj));
   var propnames = getObjProps(model);
   var isFirst = true;
   for (var i, 0, genNumProps(model) - 1, 1)
      var modelPr = model[i];
      var propVal = obj[i];
      if (isEqClass("FieldClass", modelPr) and (ValType(propVal) != V_UNDEF))
         if (not(isFirst))
            result = result + ",";
         end;
         var fieldName = propnames[i];
         if (isEqClass("CustomField", modelPr))
            fieldName = modelPr.fieldName;
         end;
         var keystr    = formatJsonKey(fieldName);
         var valuestr  = modelPr.formatJSON(propVal, @SomeToJSONString);

         result = result + keystr + valuestr;
         isFirst = false;
      end;
   end;
   result = result + "}";
   return result;
End;

Private Macro arrayToJSONString(arr, itemstype)
   var result = "[";
   var isFirst = true;
   var part;

   for (var p, arr)
      if (isFirst == false)
         result = result + ",";
      end;
      result = result + itemstype.formatJSON(p, @SomeToJSONString);
      isFirst = false;
   end;
   result = result + "]";
   return result;
End;


/**
   Возвращает форматированную JSON строку с отступами в 'indent' пробелов (по умолчанию 4).
*/
Macro PrettifyJSON(sourcestr : String, indent : Integer) : String
   if (ValType(indent) != V_INTEGER)
      indent = 4;
   end;
   var result = "";
   var s;
   var curTab = 0;
   var curTabStr = "";
   var open = false;
   for (var i, 1, StrLen(sourcestr), 1)
      s = SubStr(sourcestr, i, 1);
      if (open == false)
         if ((s == "{") or (s == "["))
            result = result + s + "\n";
            curTab = curTab + indent;
            curTabStr = SU.repeat(" ", curTab);
            result = result + curTabStr;
         elif ((s == "}") or (s == "]"))
            curTab = curTab - indent;
            curTabStr = SU.repeat(" ", curTab);
            result = result + "\n" + curTabStr + s;
         elif (s == ":")
            result = result + s + " ";
         elif (s == ",")
            result = result + s + "\n" + curTabStr;
         elif (s == "\"")
            result = result + s;
            open = true;
         else
            result = result + s;
         end;
      else
         if (s == "\"")
            open = false;
         end;
         result = result + s;
      end;
   end;
   return result;
End;

/**
   Возвращает минифицированную JSON строку из строки 'sourcestr'
*/
Macro MinifyJSON(sourcestr) : String
   var result = "";
   var s;
   var open = false;
   for (var i, 1, StrLen(sourcestr), 1)
      s = SubStr(sourcestr, i, 1);
      if ((s == " ") and (open == false))
         s = "";
      elif (s == "\n")
         s = "";
      elif (s == "\r")
         s = "";
      elif (s == "\"")
         open = not(open);
      end;
      result = result + s;
   end;
   return result;
End;


/**
   Класс парсер JSON. Для использования необходимо создать объект этого класса.
*/
Class JSONParser()

   /**
      Преобразует валидную строку JSON 'jsonString' в объект класса 'pojoClassName', или массив объектов.
   */
   Macro parse(jsonString : String, pojoClassName : Variant)
      return ParseFromJSON(jsonString, pojoClassName);
   End;

   /**
      Возвращает валидную JSON строку из объекта или массива 'sourceObj'.
   */
   Macro toJSON(sourceObj : Object, typeObject) : String
      if (ValType(typeObject) == V_UNDEF)
         typeObject = VariantField;
      end;
      return SomeToJSONString(sourceObj, typeObject);
   End;
End;

var dtformatt = TU_DateFormat("yyyy-MM-ddTHH:mm:ss.S");
var dtformat2 = TU_DateFormat("yyyy-MM-dd");

Class Planet()
   var name = StringField;
   var rotation_period = IntegerField;
   var residents = ArrayField(V_STRING);
   var someShit  = IntegerField;
   var som     = ObjectField("Som");
   var friends = ArrayField("Som");
   var numb = IntegerField;
   var flag = BoolField;
End;

Class Som()
   var name = StringField;
   var age  = IntegerField;
   var _date = DateField(dtformatt);
End;

Class Person()
   var name = StringField;
   var created = DateField();

End;
/*
var fl  = TStreamDoc("../mac/old/extra_/jsont.txt", "R", "utf8");
var fl2 = TStreamDoc("../mac/old/extra_/jsonarr.json", "R", "utf8");
var fl3 = TStreamDoc("../mac/old/extra_/people.json", "R", "utf8");

var i;
var str;


fl.readLine(str);

var par = JSONParser();

var obj = par.parse(str, "Planet");
debugbreak;
var res = par.toJSON(obj);
var pret = prettifyJSON(res);

var minj = minifyJSON(pret);
var obj2 = par.parse(minj, "Planet");

fl2.readLine(str);
debugbreak;
var arr = par.parse(str, "som");
exit();
var p = GetPropOrNull(arr, "[0].date");
var inverse = par.toJSON(SArray(1, 2, true, "http:/google.com"));

println(prettifyJSON(inverse));
*/