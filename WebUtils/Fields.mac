/**
   @Package WebUtils
   Реализация холдеров полей класса для JSONParser.
*/
import "..\\mac\\extra\\Lambda\\Lambda.mac";

/** Тип строки. */
Const StringField  = GenObject("StringFieldClass");
/** Тип целого числа. */
Const IntegerField = GenObject("IntegerFieldClass");
/** Тип числа c дробной частью. */
Const DoubleField  = GenObject("DoubleFieldClass");
/** Денежный тип. */
Const MoneyField   = GenObject("MoneyFieldClass");
/** Булев тип. */
Const BoolField    = GenObject("BoolFieldClass");
/** Тип смешанных примитивов.*/
Const VariantField = GenObject("VariantFieldClass");

/** Базовый класс, не реализует функциональность. */
Class FieldClass()
   Macro parseValue(strVal, callbackFunc)
   End;

   Macro formatJSON(value, callbackFunc)
   End;

   Macro formatXML(value, callbackFunc)
   End;
End;

Private Class (FieldClass) PrimFieldClass()
   Macro parseValue(strVal : Variant)
      if (ValType(strVal) != V_UNDEF)
         return strVal;
      else
         return null;
      end;
   End;

   Macro formatJSON(val)
      return val;
   End;
End;

Private Class (PrimFieldClass) VariantFieldClass()
   Macro _isNumber(str) : Bool
      for (var i, 1, StrLen(str), 1)
         var c = CodeFor(SubStr(str, i, 1));
         if ((c < 48) or (c > 57))
            return false;
         end;
      end;
      return true;
   End;

   Macro parseValue(strVal : Variant)
      if (ValType(strVal) != V_UNDEF)
         var lwr = Trim(StrLwr(strVal));
         var p1 = Index(lwr, ".");
         var p2 = Index(lwr, ".", p1+1);
         var f = SubStr(lwr, 1, 1);
         if (lwr == "true")
            return true;
         elif (lwr == "false")
            return false;
         elif (_isNumber(lwr))
            return Int(lwr);
         elif ((p1 > 0) and (p2 <= 0))
            return Double(lwr);
         elif (f == "{")
            return null;
         else
            return strVal;
         end;
      else
         return null;
      end;
   End;

   Macro formatJSON(val)
      return StrLwr(String(val));
   End;
End;

Private Class (PrimFieldClass) StringFieldClass()

   Macro parseValue(val)
      val = StrSubst(val, "\\\"", "\"");
      return val;
   End;

   Macro formatJSON(val)
      return "\"" + StrSubst(val, "\"", "\\\"") + "\"";
   End;
End;

Private Class (PrimFieldClass) IntegerFieldClass()

   Macro parseValue(strVal : String)
      return Int(strVal);
      OnError
         return null;
   End;
End;

Private Class (PrimFieldClass) DoubleFieldClass()

   Macro parseValue(strVal : String)
      return Double(strVal);
      OnError
         return null;
   End;

End;

Private Class (PrimFieldClass) MoneyFieldClass()

   Macro parseValue(strVal : String)
      return Money(strVal);
      OnError
         return null;
   End;
End;

Private Class (PrimFieldClass) BoolFieldClass()

   Macro parseValue(strVal : String)
      return (StrLwr(strVal) == "true");
      OnError
         return null;
   End;

   Macro formatJSON(val)
      return StrLwr(String(val));
   End;
End;

/**
   Тип даты времени. Принимает на вход обязательный параметр 'dtformat' типа  [Utils.TU_DateFormat]. После парсинга поля возращает значение типа [Utils.TU_DateTime].
*/
Class (PrimFieldClass) DateTimeField(dtformat)
   var format = dtformatter;

   Macro parseValue(strVal : String)
      return format.parse(strVal);
      OnError
         return null;
   End;

    Macro formatJSON(val) : String
      return "\"" + format.format(val) + "\"";
   End;
End;

/**
   Тип даты. Принимает на вход обязательный параметр 'dtformat' типа  [Utils.TU_DateFormat]. После парсинга поля возращает значение RSL типа 'V_DATE'.
*/
Class (PrimFieldClass) DateField(dtformat)
   var format = dtformatter;

   Macro parseValue(strVal : String)
      var ret = format.parse(strVal).getDate();
      return ret;
      OnError
         return null;
   End;

   Macro formatJSON(val)
      return "\"" + format.format(val) + "\"";
   End;
End;

/**
   Тип даты. Принимает на вход обязательный параметр 'dtformat' типа  [Utils.TU_DateFormat]. После парсинга поля возращает значение RSL типа 'V_TIME'.
*/
Class (PrimFieldClass) TimeField(dtformat)
   var format = dtformat;

   Macro parseValue(strVal : String)
      return format.parse(strVal).getTime();
      OnError
         return null;
   End;

   Macro formatJSON(val)
      return "\"" + format.format(val) + "\"";
   End;
End;

/**
   Тип объекта. Принимает на вход обязательный параметр '_className', имя класса соответсвующего полю.
*/
Class (FieldClass) ObjectField(_className)
   var className = _className;

   Macro parseValue(strVal : String, callbackFunc)
      return ExecMacro2(callbackFunc, strVal, className);
   End;

   Macro formatJSON(val, callbackFunc)
      return ExecMacro2(callbackFunc, val, className);
   End;
End;

/**
   Тип массива. Принимает на вход обязательный параметр '_itemsType',
   это может быть
      - имя класса объектов
      - объект типа  [FieldClass] (предпочтительно), соответсвующий типу элементов массива.
      - RSL тип для примитивных типов (V_STRING, V_INTEGER)

*/
Class (FieldClass) ArrayField(_itemsType)
   var itemstype = null;

   Macro parseValue(strVal : String, callbackFunc)
      return ExecMacro2(callbackFunc, strVal, itemstype);
   End;

   Macro formatJSON(val, callbackFunc)
      return ExecMacro2(callbackFunc, val, itemstype);
   End;

   Macro ini(tp)
      if (ValType(tp) == V_INTEGER)
         if (tp == V_INTEGER)
            itemstype = IntegerField;
         elif (tp == V_STRING)
            itemstype = StringField;
         end;
      elif (ValType(tp) == V_STRING)
         itemstype = ObjectField(tp);
      elif (IsEqClass("FieldClass", tp))
         itemstype = tp;
      else
         RunError("\nНе верный тип элементов массива ArrayField");
      end;
   End;

   ini(_itemsType);
End;

Private Macro fieldAsIs(val)
   return val;
end;

/**
   Пользователький тип. Необходим в случаях когда имя поля класса не соответствует имени в JSON или XML, или необходимо выполнить дополнительные преобразования при парсинге или форматировании строки.
   @param  _fieldName         - имя поля в JSON.
   @oparam _mapParser         - ссылка на функцию или лямбда выражение для преобразование при парсинге JSON. Если не задана, функция вернет значение поля "как есть".
   @oparam _map_mapFormatterr - ссылка на функцию или лямбда выражение для преобразование при форматировании строки. Если не задана, функция вернет значение поля "как есть".
*/
Class (FieldClass) CustomField(_fieldName : String, _mapParser, _mapFormatter)
   var fieldName = null;
   var mapParser = _mapParser;
   var mapFormatter = _mapFormatter;

   Macro parseValue(strVal : String) : Variant
      return ExecMacro2(mapParser, strVal);
      OnError
         return null;
   End;

   Macro formatJSON(val) : String
      return "\"" + String(ExecMacro2(mapFormatter, val)) + "\"";
   End;

   if (ValType(_fieldName) != V_STRING)
      RunError("fieldName should be type of String");
   else
      fieldName = StrLwr(_fieldName);
   end;
   if (ValType(mapParser) != V_UNDEF)
      mapParser = Lambdas.getFunc(mapParser);
   else
      mapParser = @FieldAsIs;
   end;
   if (ValType(mapFormatter) != V_UNDEF)
      mapFormatter = Lambdas.getFunc(mapFormatter);
   else
      mapFormatter = @FieldAsIs;
   end;
End;

Private Macro getPropVal(obj, pn)
   if (moduleName(pn) == "SYSTEM")
      pn = "_" + pn;
   end;
   var i = GenPropId(obj, pn);
   if (i >= 0)
      return obj[i];
   end;
End;

Private Macro getPropValByInd(obj, ind)
   if (ValType(obj) == V_GENOBJ)
      if (IsEqClass("TARRAY", obj))
         if ((ind >= 0) and (ind < obj.size))
            return obj[ind];
         end;
      else
         if ((ind >= 0) and (ind < GenNumProps(obj)))
            return obj[ind];
         end;
      end;
   end;
   return null;
end;

/**
   Возвращает значение поля в объекте 'obj' по пути 'objpath' или `null`, если поле не существует. Не бросает ошибок.

   Путь может состоять из:
   - имён полей разделенных `.`
   - индекса заключенного в `[]`. Можно извлекать как элемент массива, так и поле объекта, например приватное.

   Например:
   ```
      var obj = SomeClassObject();
      var val = getPropOrNull(obj, "field.arr[0]");
   ```
*/
Macro getPropOrNull(obj : Object, objpath : String)
   if (ValType(obj) != V_GENOBJ)
      return null;
   end;
   var finded = obj;
   var propn = "";
   for (var i, 1, StrLen(objpath), 1)
      if (ValType(finded) != V_GENOBJ)
         return null;
      end;
      var s = SubStr(objpath, i, 1);
      if (s == ".")
         if (propn != "")
            finded = getPropVal(finded, propn);
            propn = "";
         end;
      elif (s == "[")
         if (propn != "")
            finded = getPropVal(finded, propn);
            propn = "";
         end;
      elif (s == "]")
         if (propn != "")
            var ind = Int(propn);
            finded = finded[ind];
            propn = "";
         end;
      else
         propn = propn + s;
      end;
   end;
   if (propn != "")
      finded = getPropVal(finded, propn);
   end;
   return finded;
   OnError
      return null;
End;
/*
   Возвращает значение поля в объекте 'obj' по пути 'objpath' или 'defval', если поле не существует. Не бросает ошибок.
*/
Macro getPropOrVal(obj : Object, objpath : String, defVal : Variant)
   var v = getPropOrNull(obj, objpath);
   if (ValType(v) != V_UNDEF)
      return v;
   end;
   return defVal;
End;

Macro gpon(obj : Object, objpath : String)
   return getPropOrNull(obj, objpath);
End;

Macro gpov(obj : Object, objpath : String,  defVal : Variant)
   return getPropOrVal(obj, objpath, defVal);
End;


