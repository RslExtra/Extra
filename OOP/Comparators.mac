import rcw;
/**
   @package OOP
   Реализованные функции-компараторы (compare и equals).
*/

/** Сравнение двух примитивных типов средствами языка (==, >, <).
    Для скорости сортировки, аргументы не проверяются на 'null` или соответствие типов значения */
Macro CF_ComparePrimitive(el1 : Variant, el2 : Variant) : Integer
   if(el1 > el2)
      return 1;
   elif(el1 < el2)
      return -1;
   else
      return 0;
   end;
End;

/** Сравнение примитивных типов с учетом возможности аргументов == Null */
Macro CF_CompareNullable(el1 : Variant, el2 : Variant) : Integer
   var n1 = (ValType(el1) == V_UNDEF);
   var n2 = (ValType(el2) == V_UNDEF);
   if(n1 and n2)
      return 0;
   elif(n1)
      return -1;
   elif(n2)
      return 1;
   else
      return CF_ComparePrimitive(el1, el2);
   end;
End;

/**
   Сравнение двух экземпляров пользовательского класса, реализующих метод `compareTo(otherObj) : Integer`.
   Способен принимать `null` в качестве аргументов, однако результат сравнения с null должен быть определен в `compareTo`
*/
Macro CF_CompareToImpl(o1, o2)
   if (ValType(o1) != V_UNDEF)
      return o1.compareTo(o2);
   elif (ValType(o2) != V_UNDEF)
      return -o2.compareTo(o1);
   else
      return 0;
   end;
End;

/**
   Проверка равенства двух экземпляров пользовательского класса, реализующих метод `Equals(otherObj) : Bool`.
   Способен принимать `null` в качестве аргументов, однако результат сравнения с null должен быть определен в `Equals`
*/
Macro CF_EqualsImpl(o1 : Object, o2 : Object) : Bool
   if (ValType(o1) != V_UNDEF)
      return o1.equals(o2);
   elif (ValType(o2) != V_UNDEF)
      return o2.equals(o1);
   else
      return true;
   end;
End;

/**
   Проверка равенства двух экземпляров пользовательского класса, реализующих метод `compareTo(otherObj) : Integer`.
   Возвращает `true` если `compareTo` вернет 0.
   Способен принимать `null` в качестве аргументов, однако результат сравнения с null должен быть определен в `Equals`
*/
Macro CF_EqualsByCompareTo(o1 : Object, o2 : Object) : Bool
    return (CF_CompareToImpl(o1, o2) == 0);
End;


Private Macro isEqualProp(p1, p2) : Bool
   var t1 = ValType(p1);
   var t2 = ValType(p2);
   if (t1 != t2) return false; end;

   if ((t1 <= 10) or (t1 == V_NUMERIC)) return (p1 == p2);  // null, примитивы и numeric
   elif (t1 == V_GENOBJ) return ExecMacro2("CF_objectEquals", p1, p2);  // Объекты
   elif (t1 == V_ARRAY)                               // Массивы
      if(t1.size != t2.size) return false; end;
      for(var i, 0, t1.size-1)
         if(isEqualProp(t1[i], t2[i]) == false)
            return false;
         end;
      end;
      return true;
   else
      return true;                                   // Ссылки на файлы, методы, считаем несущественными
   end;
   return true;
End;

/**
   Функция проверки на равенство двух примитивов одного типа.
*/
Macro CF_EqualsPrimitive(p1, p2) : Bool
   return (p1 == p2);
End;
/**
   Проверка объектов на полное равенство по свойствам (в т.ч вложенным и массивам).

   Сравнение происходит по следующим правилам:
   - Свойства, являющиеся примитивны ми типами RSL, проверяются на равенство средствами языка (==).
   - Свойства, являющиеся ссылкой на объект будут рекурсивно проверенны по примитивным свойствам.
   - Свойства, являющиеся массивами (TArray) будут проверены по размеру, а при равенстве, попарно по индексу.
*/
Macro CF_ObjectEquals(o1, o2) : Bool
   if (IsEqClass(GenClassName(o1), o2) == false) return false; end;
   var pc = GenNumProps(o1);
   for (var i, 0, pc-1, 1)
      if (isEqualProp(o1[i], o2[i])==false)
         return false;
      end;
   end;
   return true;
End;


private var tmpArr = TArray();

/**
   Объект-компаратор генерирует метод-компаратор и предоставляет ссылку на него методом [getFunc].
   Инициализируется списком имен свойств объекта для сравнения, от более весомого к более низкому (как ключ в базе).
   Если порядок должен быть обратным, необходимо указать знак '-' перед именем свойства.
   Поля должны быть примитивного типа. Сравнение полей проходит в натуральном порядке. Поля могут быть `null`, при этом
   два поля `null` считаются равными, но `null` меньше любого примитива.

   @oparam varargs - имена свойств объектов (являющихся примитивами) одного класса для сравнения.
 */
Class CF_ObjectComparator()
   private var propsName = TArray();
   private var order     = TArray();
   local var i, pr;
   for (i, 1, Parmcount-1, 1)
      GetParm(i, pr);
      if (SubStr(pr, 1, 1) == "-")
         propsName.value(i-1) = SubStr(pr, 2);
         order.value(i-1) = -1;
      else
         propsName.value(i-1) = pr;
         order.value(i-1) = 1;
      end;
   end;
   tmpArr[tmpArr.size] = this;

   /**
      Возвращает результат сравнения двух объектов.
   */
   Macro compare(o1, o2) : Integer
      for (var i, 0, propsName.size-1, 1)
         var p  = propsName[i];
         var p1 = GenGetProp(o1, p);
         var p2 = GenGetProp(o2, p);
         var t1 = ValType(p1);
         var t2 = ValType(p2);
         if ((t1 != V_UNDEF) and (t2 != V_UNDEF))
            var resCompare = CF_ComparePrimitive(p1, p2);
            if(resCompare != 0)
               return resCompare*order[i];
            end;
         elif (t1 == V_UNDEF)
            return -order[i];
         end;
      end;
      return 0;
   End;

   /**
      Возвращает ссылку на метод [compare].
   */
   Macro getFunc()
      return (R2M(this, "compare"));
   End;
End;

/**
   Объект-компаратор генерирует метод-компаратор и предоставляет ссылку на него методом [getFunc].
   Схож с [CF_ObjectComparator], однако сравнивает объекты одного класса, в конструктор он передается первым параметром 'obj'. Далее следуют имена полей, в т.ч и приватных! Если поля с таким именем не найдено у объекта будет брошена ошибка.
*/
Class CF_ObjectComparator2(obj)
   private var propsId   = TArray();
   private var order     = TArray();
   if (ValType(obj) != V_GENOBJ)
      RunError("Первый входящий параметр CF_ObjectComparator2 должен быть объектного типа");
   end;
   local var i, j, pr, nm, p;
   local var props = GetObjProps(obj);
   for (i, 2, Parmcount-1, 1)
      GetParm(i, pr);
      if (SubStr(pr, 1, 1) == "-")
         nm = SubStr(pr, 2);
         order.value(i-2) = -1;
      else
         nm = pr;
         order.value(i-2) = 1;
      end;
      j = 0;
      for (p, props)
         if (p == StrUpr(nm))
            propsId[i-2] = j;
            break;
         end;
         j = j + 1;
      end;
      if (ValType(propsId[i-2]) == V_UNDEF)
         RunError("У объекта отсутсвует поле с именем " + nm);
      end;
   end;
   tmpArr[tmpArr.size] = this;

   /**
      Возвращает результат сравнения двух объектов.
   */
   Macro compare(o1, o2) : Integer
      for (var i, 0, propsId.size-1, 1)
         var ind  = propsId[i];
         var p1 = o1[ind];
         var p2 = o2[ind];
         var t1 = ValType(p1);
         var t2 = ValType(p2);
         if ((t1 != V_UNDEF) and (t2 != V_UNDEF))
            var resCompare = CF_ComparePrimitive(p1, p2);
            if(resCompare != 0)
               return resCompare*order[i];
            end;
         elif (t1 == V_UNDEF)
            return -order[i];
         end;
      end;
      return 0;
   End;

   /**
      Возвращает ссылку на метод [compare].
   */
   Macro getFunc()
      return (R2M(this, "compare"));
   End;
End;

/**
   Объект для сравнения объектов типа [Collections.Pair] по ключу согласно функции 'keyComparator'. Методом [CF_PairsComparator.getFunc getFunc()] возвращается необходимая функция компаратор.
*/
Class CF_PairsComparator(keyComparator)
   var comparator = keyComparator;
   tmpArr[tmpArr.size] = this;

   Macro compare(p1, p2) : Integer
      return ExecMacro2(comparator, p1.key, p2.key);
   End;
   /**
      Возвращает функцию-компаратор, которая принимает две [Collections.Pair] и возвращает результат сравнения по их ключам.
   */
   Macro getFunc()
      return R2M(this, "compare");
   End;
End;