import rcw;
/**
   @package OOP
   Реализованные функции-компараторы (compare и equals).
*/

/**
   Сравнение двух примитивных типов средствами языка (==, >, <).
   Для лучшей скорости сортировки, аргументы не проверяются на 'null` или соответствие типов значения
*/
Macro CF_ComparePrimitive(el1 : Variant, el2 : Variant) : Integer
   if(el1 > el2)
      return 1;
   elif(el1 < el2)
      return -1;
   else
      return 0;
   end;
End;

/** Сравнение примитивных типов с учетом возможности аргументов == Null */
Macro CF_CompareNullable(el1 : Variant, el2 : Variant) : Integer
   var n1 = (ValType(el1) == V_UNDEF);
   var n2 = (ValType(el2) == V_UNDEF);
   if(n1 and n2)
      return 0;
   elif(n1)
      return -1;
   elif(n2)
      return 1;
   else
      return CF_ComparePrimitive(el1, el2);
   end;
End;

/**
   Сравнение двух строк без учета регистра.
*/
Macro CF_CompareStrIgnoreCase(s1 : String, s2 : String) : Integer
   s1 = StrUpr(s1);
   s2 = StrUpr(s2);
   if (s1 == s2)
      return 0;
   elif (s1 < s2)
      return -1;
   else
      return 1;
   end;
End;

/**
   Сравнение двух экземпляров пользовательского класса, реализующих метод `compareTo(otherObj) : Integer`.
   Способен принимать `null` в качестве аргументов, однако результат сравнения с null должен быть определен в `compareTo`
*/
Macro CF_CompareToImpl(o1, o2)
   if (ValType(o1) != V_UNDEF)
      return o1.compareTo(o2);
   elif (ValType(o2) != V_UNDEF)
      return -o2.compareTo(o1);
   else
      return 0;
   end;
End;

/**
   Универсальная функция-компаратор для двух переменных RSL 'o1' и 'o2'. Для двух примитивов одного типа проведет сравнение через `> < ==`, если примитивы будут разного типа бросит ошибку. Для аргументов разных типов вернет результат сравнения числовых констант типов, т.е по возрастанию будут идти (Undefined, Integer, String и т.д ). Для объектных типов попробует выполнить метод `compareTo(obj) : Integer`, если такой метод не будет определен в классе, бросит ошибку. Если оба элемента равны `null` вернет 0. Работает медленней чем собственные функции-компараторы, но за константное время, т.е. не усложняет алгоритм использующий эту функцию.
*/
Macro VariantCompare(o1: Variant, o2: Variant) : Integer
   var t1 = ValType(o1);
   var t2 = ValType(o2);
   var sign = 1;
   if (t1 != t2)
      return (t1-t2);
   end;

   if (t1 == V_UNDEF)
      return 0;
   elif (t1 <= V_TIME)                    // Примитивы
      return CF_ComparePrimitive(o1, o2);
   elif (t1 == V_GENOBJ)            // Объекты
      var rCmp = ExecMacro2(R2M(o1,"compareTo"), o2);
      if (ValType(rCmp) == V_INTEGER)
         return sign*rCmp;
      end;
      RunError("\nДля класса " + GenClassName(o1) + " не определена функция CompareTo(otherObj) : Integer");
   end;
   return CF_ComparePrimitive(o1, o2);
End;

/**
   Проверка равенства двух экземпляров пользовательского класса, реализующих метод `Equals(otherObj) : Bool`.
   Способен принимать `null` в качестве аргументов, однако результат сравнения с null должен быть определен в `Equals`
*/
Macro CF_EqualsImpl(o1 : Object, o2 : Object) : Bool
   if (ValType(o1) != V_UNDEF)
      return o1.equals(o2);
   elif (ValType(o2) != V_UNDEF)
      return o2.equals(o1);
   else
      return true;
   end;
End;

/**
   Проверка равенства двух экземпляров пользовательского класса, реализующих метод `compareTo(otherObj) : Integer`.
   Возвращает `true` если `compareTo` вернет 0.
   Способен принимать `null` в качестве аргументов, однако результат сравнения с null должен быть определен в `Equals`
*/
Macro CF_EqualsByCompareTo(o1 : Object, o2 : Object) : Bool
    return (CF_CompareToImpl(o1, o2) == 0);
End;


Private Macro isEqualProp(p1, p2) : Bool
   var t1 = ValType(p1);
   var t2 = ValType(p2);
   if (t1 != t2) return false; end;

   if ((t1 <= 10) or (t1 == V_NUMERIC)) return (p1 == p2);  // null, примитивы и numeric
   elif (t1 == V_GENOBJ) return ExecMacro2("CF_objectEquals", p1, p2);  // Объекты
   elif (t1 == V_ARRAY)                               // Массивы
      if(t1.size != t2.size) return false; end;
      for(var i, 0, t1.size-1)
         if(isEqualProp(t1[i], t2[i]) == false)
            return false;
         end;
      end;
      return true;
   else
      return true;                                   // Ссылки на файлы, методы, считаем несущественными
   end;
   return true;
End;

/**
   Функция проверки на равенство двух примитивов одного типа.
*/
Macro CF_EqualsPrimitive(p1, p2) : Bool
   return (p1 == p2);
End;

/**
   Функция проверки на равенство двух строк без учета регистра.
*/
Macro CF_StrEqualsIgnoreCase(s1 : String, s2 : String) : Bool
   return (StrUpr(s1) == StrUpr(s2));
End;
/**
   Проверка объектов на полное равенство по свойствам (в т.ч вложенным и массивам).

   Сравнение происходит по следующим правилам:
   - Свойства, являющиеся примитивны ми типами RSL, проверяются на равенство средствами языка (==).
   - Свойства, являющиеся ссылкой на объект будут рекурсивно проверенны по примитивным свойствам.
   - Свойства, являющиеся массивами (TArray) будут проверены по размеру, а при равенстве, попарно по индексу.
*/
Macro CF_ObjectEquals(o1, o2) : Bool
   if (IsEqClass(GenClassName(o1), o2) == false) return false; end;
   var pc = GenNumProps(o1);
   for (var i, 0, pc-1, 1)
      if (isEqualProp(o1[i], o2[i])==false)
         return false;
      end;
   end;
   return true;
End;
/**
   Универсальная функция проверки на равенство двух переменных RSL 'o1' и 'o2'.

   Функция работает по следующему принципу:
   - Если аргументы разных типов вернет `false`,
   - Если одного примитивного типа, пернет результат сравнения через `==`.
   - Для объектных аргументов, попробует вызвать метод `equals(obj) : Bool`, а затем если не будет найден 'compareTo'. Если ни один из методов не определен бросит ошибку.
   - Если аргументы равны `null`, вернет `true`.
   - Если аргументы типа [TArray] или наследного класса, вернет результат функции [TArrayEquals], которая попарно сравнивает элементы обоих массивов.
*/
Macro VariantEquals(o1: Variant, o2: Variant) : Bool
   var t1 = ValType(o1);
   var t2 = ValType(o2);
   if (t1 != t2) return false; end;
   if (t1 <= 10)                    // Примитивы
      return (o1 == o2);
   elif (t1 == V_GENOBJ)            // Объекты
      if (isEqClass("TArray", o1))
         return ExecMacro2("TArrayEquals", o1, o2);
      end;
      var rEq = ExecMacro2(R2M(o1,"equals"), o2);
      if (ValType(req) == V_BOOL) return req; end;
      var rCmp = ExecMacro2(R2M(o1,"compareTo"), o2);
      if (ValType(rCmp) == V_INTEGER)
         return (rCmp == 0);
      end;
      RunError("\nДля класса " + GenClassName(o1) + " не определена функция Equals(otherObj) : Bool");
   end;
   return (o1 == o2);
End;

/**
   Функция эквивалентности двух массивов [TArray]. Последовательно вызывает для каждой пары элементов массивов [VariantEquals].
   Если в результате сравнеия хоть одна пара не эквивалентна, вернет `false`.
*/
Macro TArrayEquals(arr1, arr2) : Bool
   if (arr1.size != arr2.size) return false; end;
   for(var i, 0, arr1.size - 1, 1)
      if (VariantEquals(arr1[i], arr2[i]) == false)
         return false;
      end;
   end;
   return true;
End;


private var tmpArr = TArray();

/**
   Объект-компаратор генерирует метод-компаратор и предоставляет ссылку на него методом [getFunc].
   Инициализируется списком имен свойств объекта для сравнения, от более весомого к более низкому (как ключ в базе).
   Если порядок должен быть обратным, необходимо указать знак '-' перед именем свойства.
   Поля должны быть примитивного типа. Сравнение полей проходит в натуральном порядке. Поля могут быть `null`, при этом
   два поля `null` считаются равными, но `null` меньше любого примитива.

   @oparam varargs - имена свойств объектов (являющихся примитивами) одного класса для сравнения.
 */
Class CF_ObjectComparator()
   private var propsName = TArray();
   private var order     = TArray();
   local var i, pr;
   for (i, 1, Parmcount-1, 1)
      GetParm(i, pr);
      if (SubStr(pr, 1, 1) == "-")
         propsName.value(i-1) = SubStr(pr, 2);
         order.value(i-1) = -1;
      else
         propsName.value(i-1) = pr;
         order.value(i-1) = 1;
      end;
   end;
   tmpArr[tmpArr.size] = this;

   /**
      Возвращает результат сравнения двух объектов.
   */
   Macro compare(o1, o2) : Integer
      for (var i, 0, propsName.size-1, 1)
         var p  = propsName[i];
         var p1 = GenGetProp(o1, p);
         var p2 = GenGetProp(o2, p);
         var t1 = ValType(p1);
         var t2 = ValType(p2);
         if ((t1 != V_UNDEF) and (t2 != V_UNDEF))
            var resCompare = CF_ComparePrimitive(p1, p2);
            if(resCompare != 0)
               return resCompare*order[i];
            end;
         elif (t1 == V_UNDEF)
            return -order[i];
         end;
      end;
      return 0;
   End;

   /**
      Возвращает ссылку на метод [compare].
   */
   Macro getFunc()
      return (R2M(this, "compare"));
   End;
End;

/**
   Объект-компаратор генерирует метод-компаратор и предоставляет ссылку на него методом [getFunc].
   Схож с [CF_ObjectComparator], однако сравнивает объекты одного класса, в конструктор он передается первым параметром 'obj'. Далее следуют имена полей, в т.ч и приватных. Если поле с таким именем не найдено у любого из объектов, будет брошена ошибка.
*/
Class CF_ObjectComparator2(obj)
   private var propsId   = TArray();
   private var order     = TArray();
   if (ValType(obj) != V_GENOBJ)
      RunError("Первый входящий параметр CF_ObjectComparator2 должен быть объектного типа");
   end;
   local var i, j, pr, nm, p;
   local var props = GetObjProps(obj);
   for (i, 2, Parmcount-1, 1)
      GetParm(i, pr);
      if (SubStr(pr, 1, 1) == "-")
         nm = SubStr(pr, 2);
         order.value(i-2) = -1;
      else
         nm = pr;
         order.value(i-2) = 1;
      end;
      j = 0;
      for (p, props)
         if (p == StrUpr(nm))
            propsId[i-2] = j;
            break;
         end;
         j = j + 1;
      end;
      if (ValType(propsId[i-2]) == V_UNDEF)
         RunError("У объекта отсутствует поле с именем " + nm);
      end;
   end;
   tmpArr[tmpArr.size] = this;

   /**
      Возвращает результат сравнения двух объектов.
   */
   Macro compare(o1, o2) : Integer
      for (var i, 0, propsId.size-1, 1)
         var ind  = propsId[i];
         var p1 = o1[ind];
         var p2 = o2[ind];
         var t1 = ValType(p1);
         var t2 = ValType(p2);
         if ((t1 != V_UNDEF) and (t2 != V_UNDEF))
            var resCompare = CF_ComparePrimitive(p1, p2);
            if(resCompare != 0)
               return resCompare*order[i];
            end;
         elif (t1 == V_UNDEF)
            return -order[i];
         end;
      end;
      return 0;
   End;

   /**
      Возвращает ссылку на метод [compare].
   */
   Macro getFunc()
      return (R2M(this, "compare"));
   End;
End;

/**
   Объект для сравнения объектов типа [Collections.Pair] по ключу согласно функции 'keyComparator'. Методом [CF_PairsComparator.getFunc getFunc()] возвращается необходимая функция компаратор.
*/
Class CF_PairsComparator(keyComparator)
   var comparator = keyComparator;
   tmpArr[tmpArr.size] = this;

   Macro compare(p1, p2) : Integer
      return ExecMacro2(comparator, p1.key, p2.key);
   End;
   /**
      Возвращает функцию-компаратор, которая принимает две [Collections.Pair] и возвращает результат сравнения по их ключам.
   */
   Macro getFunc()
      return R2M(this, "compare");
   End;
End;