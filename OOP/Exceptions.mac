/**
   @package OOP
   @ancestor Extra

   Реализация исключений и блоков try/catch/finally.
*/

/**
   Базовый класс исключения.
*/
Class Exception (detailMessage : String)
   var msg : String = "";

   if (ValType(detailMessage) != V_UNDEF)
      msg = String(detailMessage);
   end;

   Macro getText()
      var text = "\n" + GenClassName(this);
      if (msg != "")
         text = text + "\n" + msg;
      end;
      return text;
   End;
End;

/**
   Исключение, возникающее при неверном формате входных параметрах процедуры.
*/
Class (Exception) IllegalArgumentException(detailMessage : String)
   initException(detailMessage);
End;

/**
   Исключение, возникающее при вызове метода в неверное время.
*/
Class (Exception) IllegalStateException(detailMessage : String)
   initException(detailMessage);
End;
/**
   Исключение ошибок чтения данных.
*/
Class (Exception) IOException(detailMessage : String)
   initException(detailMessage);
End;

/**
   Исключение, возникающее при обращение по неверному индексу.
*/
Class (Exception) IndexOutOfBoundsException(detailMessage : String)
   initException(detailMessage);
End;

/**
   Исключение, возникающее при невозможности получить объект.
*/
Class (Exception) NoSuchElementException(detailMessage : String)
   initException(detailMessage);
End;

/**
   Исключение, возникающее, если не импортирован необходимый макрофайл.
*/
Class (Exception) ModuleNotImportedException(detailMessage : String)
   initException(detailMessage);
End;

/**
   Исключение, возникающее, если метод не допустим к вызову.
*/
Class (Exception) UnsupportedOperationException(detailMessage : String)
   initException(detailMessage);
End;

private var ThrowMode = 0;

/**
   Задает поведение метода throw. Возможные варианты:
   - '0' - будет вызвана стандартная RSL ошибка через RunError,
   - '1' - на синий экран будет выведен StackTrace, а программа завершится.
   - '2' - метод Throw вернет объект брошенного Exception, который можно будет перехватить и обработать без предложения отладить и завершения программы.
*/
Macro setThrowMode(modeInt : Integer)
   if (ValType(modeInt) == V_UNDEF)
      modeInt = 0;
   elif ((modeInt > 2) or (modeInt < 0))
      RunError("Не верный тип поведения Throw.")
   end;
   ThrowMode = modeInt;
End;

private var LastException = null;
private var isCatchable   = false;
/**
   Служебный метод для работы в режиме Unit тестирования. Устанавливает последнее брошенное исключение.
*/
Macro setLastException(exc)
   LastException = exc;
End;

/**
   Служебный метод для работы в режиме Unit тестирования. Возвращает и удаляет из хранилища последнее исключение.
*/
Macro getLastException()
   var ret = LastException;
   LastException = null;
   return ret;
End;

/**
   Бросает исключение '_exception'. Вызывает функцию [RunError] передавая в качестве параметров текст исключения и объект исключения.
*/
Macro Throw(_exception : Exception)
   if ( Valtype(_exception) == V_UNDEF)
      _exception = Exception();
   end;
   if (isCatchable)
      setLastException(_exception);
      return;
   end;
   if (ThrowMode == 0)
      setLastException(_exception);
      RunError(_exception.getText, _exception);
   elif (ThrowMode == 1)
      printStack();
      exit(0);
   elif (ThrowMode == 2)
      setLastException(_exception);
      return _exception;
   end;
End;

Private Class CatchClass(_exception, _doFunc)
   var exc    = _exception;
   var dofunc = _doFunc;
End;

/**
   Класс реализация блока try/catch/finally.
   В вызов [try] передается ссылка на функцию которую необходимо выполнить, далее передается до 10 аргументов функции через запятую.

   Затем в методе [catch] первым аргументом указывается класс исключение - наследник [Exception], или код ошибки, если будет перехватываться стандартная 'TrslError',
   вторым аргументов указывается ссылка на функцию, которую необходимо выполнить в случае перехвата ошибки. Блоков [catch] может быть указано сколько угодно много, однако выполнится функция лишь из первого подходящего блока. Если ни один блок не перехватит исключение, будет сгенерирована ошибка 'TrslError' и программа завершится.

   Далее есть возможность указать блок [finally]. Единственным аргументом этого метода является ссылка на функцию которую необходимо выполнить, независимо, было ли брошено исключение/ошибка или нет.

   Также есть возможность обрабатывать стандартные ошибки 'TrslError'.
   Тогда, если функция передаваемая в Try вызывает ошибку 'TrslError', в вызове catch первым параметром указывается код ошибки (0  или null если необходимо перехватить любую), вторым параметром так же остается ссылка на функцию.
   В debug режиме будет показана соответствующая ошибка, однако при выборе "Нет" на вопрос ("Будем отлаживать?") программа продолжит своё выполнение если ошибка была перехвачена.

   Пример использования:
   @Sample [Samples.OOP.tryCatch]
*/
Class Try(tryfunc)
   private var isDone  : Bool  = false;
   private var func    = tryfunc;
   private var pa      = TArray();
   private var catches = TArray();
   private var finallyFunc = null;
   private var needThrow = false;
   private var lastExc   = null;

   private Macro tryCatchIt()
      var result;
      if (IsEqClass("Exception", lastExc))
         needThrow = true;
         for (var c, catches)
            if (IsEqClass(GenClassName(c.exc), lastExc))
               result = ExecMacro2(c.dofunc);
               needThrow = false;
               break;
            end;
         end;
      end;
      if (finallyFunc != null)
         ExecMacro(finallyFunc);
      end;
      return result;
   End;

   /**
      Запускает в ручную цепочку исполнения.
   */
   Macro tryRun()
      debugbreak;
      var result = ExecMacro2(func, pa[0], pa[1], pa[2], pa[3], pa[5], pa[6], pa[7], pa[8], pa[9]);
      if (isCatchable)
         lastExc = getLastException();
         result = tryCatchIt();
      end;
      return result;
      OnError(err)
         var exc = err.err;
         if (IsEqClass("Exception", exc))  // Если это Exception но не было catch
            if (finallyFunc != null)
               ExecMacro(finallyFunc);
            end;
            return;
         else
            for (var c, catches)
               var uc = c.exc;
               if (ValType(uc) == V_UNDEF)
                  uc = 0;
               end;
               if (ValType(uc) == V_INTEGER)
                  if ((err.code == uc) or (uc == 0))
                     ExecMacro(c.dofunc, err);
                     break;
                  end;
               end;
            end;
         end;
         if (finallyFunc != null)
            ExecMacro(finallyFunc);
         end;
   End;

   /**
      Метод отлавливает ошибку '_exception' и выполняет функцию '_doFunc' или пропускает ошибку к следующему catch.
   */
   Macro catch(_exception, _doFunc)
      catches[catches.size] = CatchClass(_exception, _doFunc);
      isCatchable = true;
      return this;
   End;

   /**
      Метод выполняет функцию  '_finallyFunc' не зависимо было ли бброшено исключение или нет.
   */
   Macro finally(_finallyFunc)
      finallyFunc = _finallyFunc;
      return this;
   End;

   Macro execute()
      var result = null;
      if (Not(isDone))
         result = tryRun();
      end;
      isDone = true;
      isCatchable = false;
      if (needThrow)
         RunError(lastExc.getText, lastExc);
      end;
      return result;
   End;

   Macro Destructor()
      execute();
   End;

   local var i;
   for (i, 2, parmcount - 1, 1)
      GetParm(i, pa.value(i-2))
   end;
End;
