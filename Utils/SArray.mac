/**
   @Package Utils

   Расширение стандартного класса [TArray]. Реализует всю базовую функциональность, за исключением переопределенного метода [SArray.sort sort()].

   Преимущества:
   - Имеется возможность заполнять массив при инициализации
   - Имеются дополнительные методы, позволяющие легко манипулировать содержимым
   - Имеются методы-цепочки (помечены тегом 'chain') и методы-билдеры (помечены тегом 'builder'), позволяющие выстраивать цепочки вызовов методов без сохранения промежуточного результата.
   - Переопределен метод [SArray.sort sort()], для улучшения производительности и чистоты функции-компаратора.

   @version 0.93
   @author Dzhanybaev M.P.
*/

Private Macro isBankInterLoaded()
   return (ValType(ExecMacro2("isAlpha", "a")) != V_UNDEF);
End;

Private const CREATE_LAMBDA_FUNC_NAME = "GetLambdaFunc";

Private Class SAIterator(_arr)
   private var arr  = _arr;
   private var nextIndex = 0;
   private var lastReturned;

   Macro next() : Bool
      if (arr.size > nextIndex)
         lastReturned = arr[nextIndex];
         nextIndex = nextIndex + 1;
         return true;
      end;
      return false;
   End;

   Macro item() : Variant
      return lastReturned;
   End;
End;

Private Macro isLambdaLoaded()
   return (ValType(ExecMacro2("LambdaLoadedMarker")) != V_UNDEF);
End;

Private Macro isStreamLoaded()
   return (ValType(ExecMacro2("StreamLoadedMarker")) != V_UNDEF);
End;

Private Macro CF_ComparePrimitive(el1, el2) : Integer
   if (el1 > el2)
      return 1;
   elif (el1 < el2)
      return -1;
   else
      return 0;
   end;
End;

/**
   Класс итератора массива. Для получения итератора необходимо вызвать метод [SArray.newIterator()].
   @sample [samples.sArray.Iterator]
*/
Private Class ArrayIterator(_arr : @TArray)
   var arr = _arr;
   var nextIndex : Integer = 0;
   var lastReturned;

/** Возвращает `true`, если имеется доступный для получения следующий элемент массива, `false` в противном случае. */
   Macro hasNext() : Bool
      return (nextIndex < arr.size);
   End;

/** Возвращает `true`, если имеется доступный для получения предыдущий элемент массива, `false` в противном случае.*/
   Macro hasPrev() : Bool
      return (nextIndex != 0);
   End;

/** Возвращает следующий элемент. */
   Macro next() : Variant
      lastReturned = arr[nextIndex];
      nextIndex = nextIndex + 1;
      return lastReturned;
   End;

/** Возвращает предыдущий элемент. */
   Macro prev() : Variant
      nextIndex = nextIndex - 1;
      lastReturned = arr[nextIndex];
      return lastReturned;
   End;

/** Помещает в ячейку массива новое значение.*/
   Macro set(el : Variant)
      arr[nextIndex-1] = el;
   End;

/** Добавляет в массив новое значение*/
   Macro add(el : Variant)
      for (var i, arr.size, nextIndex, -1)
         arr[i] = arr[i-1];
      end;
      arr[nextIndex] = el;
   End;

/** Удаляет текущий элемент, не оставляя дырку, перемещаясь на шаг назад, т.е следующим вызовом [ArrayIterator.next next] переходит на следующий после удаляемого элемент. */
   Macro remove()
      if (nextIndex == 0) RunError("No such element") end;
      var el = arr.remove(nextIndex - 1);
      nextIndex = nextIndex - 1;
      return el;
   End;
End;


/**
   Расширение стандартного класса [TArray].
   Массив объявляется стандартным способом, за исключением случая с предопределенными значениями.

   Пример использования:
   @sample [samples.SArray.SArray]
*/
Class (TArray) SArray()
   initTArray();
   // ------Constructor------
   local var i;
   for (i, 1, Parmcount-1, 1)
      GetParm(i, value(i-1));
   end;

   // -----------------------

   private macro getFunc(candidate)
      if (ValType(candidate) == V_UNDEF)
         return null;
      elif ((ValType(candidate) == V_STRING) and isLambdaLoaded)
         return ExecMacro2(CREATE_LAMBDA_FUNC_NAME, candidate);
      else
         return candidate;
      end;
   End;
   /**
      Возвращает `true` если массив е содержит элементов, `false` в противном случае.
   */
   Macro isEmpty() : Bool
      return (size == 0);
   End;

   /*
      Добавляет элементы указанные в качестве аргументов. Массив должен быть пустым.
      @oparam varargs - добавляемые элементы
   */
   Macro of() : SArray
      if (size != 0) RunError("Not Empty SArray cannot be initialized"); end;
      for (var i, 1, Parmcount-1, 1)
         GetParm(i, value(i-1));
      end;
      return this;
   End;

   /**
      Добавляет 'element' на позицию 'ind', сдвигая последующие элементы вправо. Если 'ind' не указан или равен `null` добавляет вконец массива. Возвращает текущий экземпляр класса.

      Пример:
      @sample [samples.sArray.add]

      @tag builder
   */
   Macro add(element : Variant, ind : Integer) : SArray
      if (ValType(ind) == V_UNDEF)
         value(size) = element;
      else
         for (var i, size, ind + 1, -1)
            value(i) = value(i-1);
         end;
         value(ind) = element;
      end;
      return this;
   end;

   /**
      Добавляет в исходный массив множество элементов из 'enumerable'.
      @sample [samples.sArray.addAll]

      @tag builder
   */
   Macro addAll(enumerable)
      for (var el, enumerable)
         value(size) = el;
      end;
      return this;
   End;

   /**
      Добавляет в исходный массив множество элементов.
      @sample [samples.sArray.addItems]

      @tag builder
      @oparam varargs
   */
   Macro addItems()
      var p;
      for (var i, 1, Parmcount-1, 1)
         GetParm(i, p);
         value(size) = p;
      end;
      return this;
   End;

   /**
      Добавляет элементы массива 'arr' в конец массива. Возвращает текущий экземпляр класса.
      @sample [samples.sArray.addArray]

      @tag builder
   */
   Macro addArray(arr) : SArray
      if (IsEqClass("TArray", arr) == false) RunError("Illegal argument"); end;
      var sz = size;
      size = size + arr.size;
      for (var i, 0, arr.size - 1, 1)
         value(sz + i) = arr[i];
      end;
      return this;
   End;

   /**
      Возвращает элемент под индексом 'ind' или бросает ошибку, если индекс выходит за границы массива.
      Метод аналогичен получению через `[]` за исключением того, что не позволит изменить элемент в массиве.
   */
   Macro get(ind) : Variant
      if (ValType(ind) == V_UNDEF) RunError("Illegal argument"); end;
      if ((ind < 0) or (ind >= size)) RunError("Index of bound"); end;
      return value(ind);
   End;

   /**
      Возвращает первый элемент массива или бросает ошибку, если массив пустой.
   */
   Macro getFirst() : Variant
      if (size == 0) RunError("No such element"); end;
      return value(0);
   End;

   /**
      Возвращает последний элемент массива или бросает ошибку, если массив пустой.
   */
   Macro getLast() : Variant
      if (size == 0) RunError("No such element"); end;
      return value(size-1);
   End;

   /**
      Удаляет и возвращает элемент под индексом 'ind', "схлопывая дырку" в массиве.
      @sample [samples.sArray.remove]
   */
   Macro remove(ind) : Variant
      var r = value(ind);
      for (var i, ind, size - 2, 1)
         value(i) = value(i + 1);
      end;
      size = size - 1;
      return r;
   End;

   /**
      Добавляет 'element' в конец массива. Возвращает текущий экземпляр класса.

      Пример:
      @sample [samples.sArray.push]

      @tag builder
   */
   Macro push(element : Variant) : SArray
      value(size) = element;
      return this;
   end;

   /**
      Удаляет и возвращает последний элемент массива, бросает ошибку если массив пустой.
      @sample [samples.sArray.pop]
   */
   Macro pop() : Variant
      if (size == 0) RunError("No such element"); end;
      var v = value(size-1);
      size = size - 1;
      return v;
   End;

   /**
      Удаляет и возвращает последний элемент массива, возвращает `null` если массив пустой.
      @sample [samples.sArray.poll]
   */
   Macro poll() : Variant
      if (size == 0) return; end;
      var v = value(size-1);
      size = size - 1;
      return v;
   End;

   /**
      Возвращает последний элемент массива (не удаляя) или `null`, если массив пустой.
      @sample [samples.sArray.peek]
   */
   Macro peek() : Variant
      if (size == 0) return; end;
      var v = value(size-1);
      return v;
   End;

   /**
      Возвращает новый массив состоящий из элементов текущего с индекса 'from' (включительно) по индекс 'to'(исключительно).
      Если не указан или равен `null` аргумент 'from' - копироваться будет с 0 аргумента.
      Если не указан или равен `null` аргумент 'to' - копироваться будет до конца массива.
      Так вызывая метод без параметров, будет создаваться копия исходного массива, при этом примитивы будут скопированны полностью, в случае объектов - скопируются ссылки.

      Пример:

      @sample [samples.sArray.slice]

      @tag chain
   */
   Macro slice(from, to) : SArray
      if (ValType(from) == V_UNDEF)
         from = 0;
      end;
      if (ValType(to) == V_UNDEF)
         to = size;
      end;
      var newArr = SArray();
      for (var i, from, to - 1, 1)
         newArr.push(value(i));
      end;
      return newArr;
   End;

   /**
      "Разворачивает" исходный массив.

      Пример:
      @sample [samples.sArray.reverse]

      @tag builder
   */
   Macro reverse() : SArray
      if (size <= 1) return this; end;
      for (var i, 0, size/2-1, 1)
         var t = value(i);
         value(i) = value(size-i-1);
         value(size-i-1) = t;
      end;
      return this;
   End;

   /**
      Возвращает новый массив, состоящий из элементов исходного и массива 'arr', исходный массив и массив 'arr' изменены не будут.

      Пример:

      @sample [samples.sArray.concat]

      @tag chain
   */
   Macro concat(arr) : SArray
      var newArr = SArray();
      if (size + arr.size  == 0) return newArr; end;
      newArr[size + arr.size - 1] = null;
      for (var i, 0, size - 1, 1);
         newArr[i] = value(i);
      end;
      for (i, 0, arr.size - 1, 1);
         newArr[i + size] = arr[i];
      end;
      return newArr;
   End;

   /**
      Возвращает индекс элемента массива 'arr' равного 'element', '-1' в случае если ничего не найдено.
      Если 'element' является 'null', функция вернет индекс первого элемента массива равный `null`.
      Так же есть возможность указать ссылку на функцию компаратор или её имя в 2 аргументе 'compfunc'.
      Функция-компаратор должна принимать два аргумента и возвращать `true` в случае их равенства.
      Если функцию-компаратор не указывать сравнение будет проходить через `==` т.е. в случае когда 'element' объектного типа, сравнение будет проходить по ссылке.

      Пример:
      @sample [samples.sArray.indexOf]
   */
   Macro indexOf(element, equalsfunc) : Integer
      var i;
      if (ValType(equalsfunc) != V_UNDEF)
         equalsfunc = getFunc(equalsfunc);
         if (ValType(element) == 19)
            var clName = GenClassName(element);
            for (i, 0, size-1, 1)
               if (isEqClass(clName, value(i)) and (ExecMacro2(equalsfunc, element, value(i))))
                  return i;
               end;
            end;
         else
            for (i, 0, size-1, 1)
               if (ExecMacro2(equalsfunc, element, value(i)))
                  return i;
               end;
            end;
         end;

      elif (ValType(element) == V_UNDEF)
         for (i, 0, size-1, 1)
            if (ValType(value(i)) == V_UNDEF)
               return i;
            end;
         end;
      else
         for (i, 0, size-1, 1)
            if ((ValType(value(i)) != V_UNDEF) and (value(i) == element))
               return i;
            end;
         end;
      end;
      return -1;
   End;

   /**
      Метод аналогичен [SArray.indexOf indexOf]; но возвращает индекс 'последнего' элемента или -1;
   */
   Macro lastIndexOf(element, equalsfunc) : Integer
      var i;
      if (ValType(equalsfunc) != V_UNDEF)
         equalsfunc = getFunc(equalsfunc);
         if (ValType(element) == 19)
            var clName = GenClassName(element);
            for (i, size-1, 0, -1)
               if (isEqClass(clName, value(i)) and (ExecMacro2(equalsfunc, element, value(i))))
                  return i;
               end;
            end;
         else
            for (i, size-1, 0, -1)
               if (ExecMacro2(equalsfunc, element, value(i)))
                  return i;
               end;
            end;
         end;
      elif (ValType(element) == V_UNDEF)
         for (i, size-1, 0, -1)
            if (ValType(value(i)) == V_UNDEF)
               return i;
            end;
         end;
      else
         for (i, size-1, 0, -1)
            if ((ValType(value(i)) != V_UNDEF) and (value(i) == element))
               return i;
            end;
         end;
      end;
      return -1;
   End;

   /**
      Возвращает `true`, если массив содержит элемент 'element', согласно функции 'equalsfunc'. Если 'equalsfunc' не указана или равняется `null`, тогда сравнение в поиске производится по ссылке через '=='.
   */
   Macro contains(element, equalsfunc) : Bool
      equalsfunc = getFunc(equalsfunc);
      return (indexOf(element, equalsfunc) >= 0);
   End;

   /**
      Возвращает `true`, если массив содержит все элементы из 'enumerable' согласно функции 'equalsFun'. Если 'equalsfunc' не указана или равняется `null`, тогда сравнение в поиске производится по ссылке через '=='.
   */
   Macro containsAll(enumerable, equalsfunc) : Bool
      equalsfunc = getFunc(equalsfunc);
      for (var el, enumerable)
         if (not (contains(el, equalsfunc)))
            return false;
         end;
      end;
      return true;
   End;

   /**
      Очищает и возвращает текущий массив.
      @sample [samples.sArray.clear]
      @tag builder
   */
   Macro clear() : SArray
      size = 0;
      return this;
   end;


   /**
      Возвращает новый массив, состоящий из элементов исходного массива 'arr', для которых функция-предикат 'predicFunc' возвращает `true`.

      Пример:

      @sample [samples.sArray.filter]

      Пример с предопределенными функциями
      @sample [samples.sArray.filter2]
      @tag chain
   */
   Macro filter(predicFunc) : SArray
      if (ValType(predicFunc) == V_UNDEF)
         RunError("Не указана функция-предикат");
      elif ((ValType(predicFunc) == V_STRING) and isLambdaLoaded)
         predicFunc = ExecMacro2(CREATE_LAMBDA_FUNC_NAME, predicFunc);
      end;
      var resArr = SArray();
      for (var el, this)
         if (ExecMacro2(predicFunc, el))
            resArr.push(el);
         end;
      end;
      return resArr;
   End;


   /**
      Возвращает новый массив преобразованных функцией 'mapFunc' всех элементов исходного массива.

      Пример:

      @sample [samples.sArray.map]

      @see [Definitions.SampleMapFunction map-функция]
      @tag chain
   */
   Macro map(mapFunc) : SArray
      if (ValType(mapFunc) == V_UNDEF)
         RunError("Не указана функция-преобразования");
      elif ((ValType(mapFunc) == V_STRING) and isLambdaLoaded)
         mapFunc = ExecMacro2(CREATE_LAMBDA_FUNC_NAME, mapFunc);
      end;
      var resArr = SArray();
      if (size != 0)
         resArr[size-1] = null;
         for (var i, 0, size-1, 1)
            resArr[i] = ExecMacro2(mapFunc, value(i));
         end;
      end;
      return resArr;
   End;

   /**
      Возвращает результат агрегатной функции 'accumulator' на элементы исходного массива.
      'identity' - начальное значение.

      Пример:
      @sample [samples.sArray.reduce]

      Пример с предопределенными функциями:
      @sample [samples.sArray.reduce2]

      @param identity начальное значение
      @param accumulator  функция-редюсер
   */
   Macro reduce(identity, accumulator) : Variant
      if (ValType(accumulator) == V_UNDEF)
         RunError("Не указана функция-редюсер");
      elif ((ValType(accumulator) == V_STRING) and isLambdaLoaded)
         accumulator = ExecMacro2(CREATE_LAMBDA_FUNC_NAME, accumulator);
      end;
      for (var el, this)
         identity = ExecMacro2(accumulator, identity, el);
      end;
      return identity;
   End;

   /**
      Вызывает 'func' для каждого элемента массива, возвращает `null`.
      Пример:

      @sample [samples.sArray.forEach]
   */
   Macro forEach(func)
      if (ValType(func) == V_UNDEF)
         RunError("Не указана функция forEach");
      elif ((ValType(func) == V_STRING) and isLambdaLoaded)
         func = ExecMacro2(CREATE_LAMBDA_FUNC_NAME, func);
      end;
      for (var el, this)
         ExecMacro(func, el);
      end;
   End;

   /**
      Возвращает `true` если массив отсортирован согласно функции-компаратору 'compfunc'.
   */
   Macro isSorted(compfunc) : Bool
      if (size <= 1) return true; end;
      if (ValType(compfunc) == V_UNDEF)
         compfunc = @CF_ComparePrimitive;
      elif ((ValType(compfunc) == V_STRING) and isLambdaLoaded)
         compfunc = ExecMacro2(CREATE_LAMBDA_FUNC_NAME, compfunc);
      end;

      for (var i, 1, size - 1, 1)
         if (ExecMacro2(compfunc, value(i-1), value(i)) > 0)
            return false;
         end;
      end;
      return true;
   End;

   /**
      Сортирует исходный массив согласно функции-компаратору 'compfunc' и возвращает ссылку на исходный массив.
      Если 'compfunc' не указана или равна `null` сортировка будет проводиться в натуральном порядке.
      Для использования необходимо предварительно импортировать 'bankinter' для возможности задействования функции QSort.

      Пример:
      @sample [samples.sArray.sort]

      @tags builder
   */
   Macro sort(compfunc) : SArray
      if (isBankInterLoaded() == false)
         RunError("Module is not loaded: bankinter");
      end;
      if (ValType(compfunc) == V_UNDEF)
         compfunc = @CF_ComparePrimitive;
      elif ((ValType(compfunc) == V_STRING) and isLambdaLoaded)
         compfunc = ExecMacro2(CREATE_LAMBDA_FUNC_NAME, compfunc);
      end;
      ExecMacro2("QSort", this, compfunc);
      return this;
   End;

   Private Macro distinctPrim() : SArray
      var resArr = SArray();
      var i, j;
      for (i, 0, size - 1, 1)
         var el = value(i);
         var uniq = true;
         for (j, 0, resArr.size - 1, 1)
            if (el == resArr[j])
               uniq = false;
               break;
            end;
         end;
         if (uniq)
            resArr.value(resArr.size) = el;
         end;
      end;
      return resArr;
   End;

   /**
      Возвращает новый массив [SArray] уникальных элементов исходного массива согласно функции 'equalsfunc'. Если 'equalsfunc' не задана или равняется `null`, сравнение будет проводиться по ссылке для объектов и по значению для примитивов через `==`.
      Функция 'equalsfunc' должна принимать два аргумента и возращать `true` если аргументы считаются равными, `false` в противном случае;

      Пример:
      @sample [samples.sArray.distinct]

      @tag chain
   */
   Macro distinct(equalsfunc) : SArray
      if (ValType(equalsfunc) == V_UNDEF)
         return distinctPrim();
      elif ((ValType(equalsfunc) == V_STRING) and isLambdaLoaded)
         equalsfunc = ExecMacro2(CREATE_LAMBDA_FUNC_NAME, equalsfunc);
      end;
      var resArr = SArray();
      var i, j;
      for (i, 0, size - 1, 1)
         var el = value(i);
         var uniq = true;
         for (j, 0, resArr.size - 1, 1)
            if (ExecMacro2(equalsfunc, el, resArr[j]))
               uniq = false;
               break;
            end;
         end;
         if (uniq)
            resArr.value(resArr.size) = el;
         end;
      end;
      return resArr;
   End;

   Private Macro findUnique(compFunc, data : @SArray, from : Integer, to : Integer, skipfirst : Bool, result : @SArray)
      if (ExecMacro2(compfunc, data[from], data[to]) == 0)
         if (skipfirst == false)
            result[result.size] = data[from];
         end;
      else
         var mid = (from + to) / 2;
         findUnique(compfunc, @data, from, mid, skipfirst, @result);
         findUnique(compfunc, @data, mid+1, to, (ExecMacro2(compfunc, data[mid], data[mid+1]) == 0), @result);
      end;
   End;

   /**
      Возвращает новый массив [SArray] уникальных элементов исходного массива в порядке возрастания согласно функции-компаратору 'compfunc'. Если 'compfunc' не задана или равняется `null`, сравнение будет проводиться по ссылке для объектов и по значению для примитивов через `> , < , ==`.
      В среднем работает быстрее чем [SArray.distinct distinct].
      @sample [samples.sArray.distinctSort]
      @tag chain
   */
   Macro distinctSort(compfunc) : SArray
      if (size == 0) return SArray(); end;
      if (ValType(compfunc) == V_UNDEF)
         compfunc = @CF_ComparePrimitive;
      elif ((ValType(compfunc) == V_STRING) and isLambdaLoaded)
         compfunc = ExecMacro2(CREATE_LAMBDA_FUNC_NAME, compfunc);
      end;
      var copyArr = slice().sort(compfunc);
      var resArr = SArray();
      findUnique(compfunc, @copyArr, 0, copyArr.size-1, false, resArr);
      return resArr;
   End;

   /**
      Объединяет элементы масcива в строку, разделяя их значением 'sep', значение 'pre' - будет добавлено в начало строки, значение 'post' в конце.
      Каждый из параметров по умолчанию равен пустой строке '""'.

      Пример:
      @sample [samples.sArray.join]

      @oparam [sep] = "" разделитель
      @oparam [pre] = "" префикс
      @oparam [pos] = "" постфикс
   */
   Macro join(sep : String, pre : String, pos : String) : String
      if (ValType(sep) == V_UNDEF) sep = ""; end;
      if (ValType(pre) == V_UNDEF) pre = ""; end;
      if (ValType(pos) == V_UNDEF) pos = ""; end;
      var res = pre;
      for (var i, 0, size - 1, 1)
         res = res + value(i);
         if (i != size - 1)
            res = res + sep;
         end;
      end;
      res = res + pos;
      return res;
   End;


   /**
      Выводит элементы массива на экран разделенные ", " внутри скобок `[]`.
   */
   Macro toScreen()
      println(join(", ", "[", "]"));
   End;

   /**
      Выводит элементы массива на экран, каждый с новой строки.
   */
   Macro toScreen2()
      for (var el, this)
         println(el);
      end;
   End;

   /**
      Создаёт массив типа [TArray] и копирует в него все элементы исходного массива.
   */
   Macro toTArray() : TArray
      var resArr = TArray();
      if (size == 0) return resArr; end;
      resArr[size-1] = null;
      for (var i, 0, size - 1)
         resArr[i] = value(i);
      end;
      return resArr;
   End;

   /** Возвращает итератор [ArrayIterator] */
   Macro newIterator() : ArrayIterator
      return GenObject("ArrayIterator", @this);
   End;

   /**
      Создает [StreamApi.BornStream Stream] объект.
   */
   Macro toStream()
      if (ValType(ExecMacro2("StreamLoadedMarker")) != V_UNDEF)
         return ExecMacro2("StreamOf", this);
      else
         RunError("Module is not loaded: Stream");
      end;
   End;

   Macro hash() : Integer

   End;

   Macro compareTo(othArr) : Integer

   End;

   Macro equals(othArr) : Bool
      if (IsEqClass("TARRAY", othArr) == false) return false; end;
      if (this == othArr) return true; end;
      if (size != othArr.size) return false; end;
      for (var i, 0, size - 1, 1)
         var v1 = value(i);
         var v2 = othArr[i];
         if (ValType(v1) == ValType(v2))
            if (v1 != v2) return false; end;
         else
            return false;
         end;
      end;
      return true;
   End;

   Macro createEnum()
      return SAIterator(this);
   End;
End;
